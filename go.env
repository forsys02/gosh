
%%% 시스템 정보 / 프로세스 관리 [p]
%% uname -a ;echo
%% echo "hostname: $(hostname) ; local_ip: $(hostname -i) ; public_ip: $(curl -s  icanhazip.com)";echo
%% w
# uptime
{ echo -ne "$(date) ; LANG: $LANG\n "; echo ; hostname ; hostname -i ; curl -s icanhazip.com ; echo ; uname -a ; echo ; { lsb_release -a 2>/dev/null && echo ; };  echo ; who am i ; echo ; w ; } | cip
vmstat ; echo ; iostat 2>/dev/null ; free -m ; echo ; df -h |cper
eval $( echo env top htop bashtop neofetch iftop dfmonitor | pipemenu ) 
# 서버 자원 체크 (tmux 창전환 ctrl-b n/p)
tmux new-session -d 'bashtop' \; new-window 'top' \; new-window 'iftop' \; new-window 'sh -c "pstree; exec bash"'; tmux attach
# pstree에서 검색된 PID 를 ps -ef 에서 상세검색 
pstree ;; v="$( pstree -pl | grep -E -- "-varFIND__go.sh\(|-\{varFIND__go.sh\}" )" ; p="$(echo $v | awk -F '[()]' '{for(i=2; i<=NF; i+=2) printf "%s|", $i; print ""}' |sed 's/|$//g')" ; echo "$v"|column -t ; [ "$p" ] && echo "$p" && ps -ef|gfind 2 "$p" | cpipe
# pstree에서 검색된 PID 를 lsof 에서 상세검색 
pstree ;; v="$( pstree -pl | grep -E -- "-varFIND__go.sh\(|-\{varFIND__go.sh\}" )" ; p="$(echo $v | awk -F '[()]' '{for(i=2; i<=NF; i+=2) printf "%s|", $i; print ""}' |sed 's/|$//g')" ; echo "$v"|column -t ; [ "$p" ] && echo "$p" && lsof|gfind 2 "$p" | cpipe 
# pstree searched PID allkill // PPID 가 1인 경우 제외 
!!! pstree -pl ;; v="$(pstree -pl | grep -E -- "-varFIND__go.sh\(|-\{varFIND__go.sh\}")" ; p="$( echo $v | awk -F '[()]' '{for(i=2; i<=NF; i+=2) printf "%s ", $i}{print ""}')" ; pg=$(echo $p|tr ' ' '|' |sed 's/|$//g') ; [ "$p" ] && echo "search: $p" && p="$( ps -ef | awk -v pg="$pg" '$2 ~ pg && $3 != 1 {printf "%s ",$2}')" && echo -n "match : $p" ; echo -n "---> kill? [Enter] " ; read x && echo $p | xargs kill
#
# top cpu 랭크 1~5 의 PID 를 ps -ef 로 상세검색 
p="$(top -bn1 | head -n30 | grep -A30 "PID USER " | awk 'NR>=2 && NR<=6 && $1>999 {printf "%s|", $1}'|sed 's/|$/\n/g')" ; [ "$p" ] && echo "$p" && ps -ef|gfind 2 "$p"
ps -ef | cpipe | less -R 
renice -n 19 -p varPID ; ionice -c2 -n7 -p varPID
!!! ps -ef | grep varFIND | awk $3 != 1 '{printf "%s ",$2}' |xargs kill -9 
!!! kill -9 varPID
# 접속기록 
last | cip24 | less -R 
{ last | head -n20 | tac ; echo ; w ; } | cip24
netstat -tulpn | grep -v :::|grep LISTEN|sort -k4 
nmap varHOST__localhost 
yyay psmisc bashtop htop neofetch iftop tmux screen bsdextrautils less net-tools nmap



%%% 서버 데몬 관리 [dm]
%% pstree | grep -E "httpd|apache|mysql|named|mail" | awk -F '-' '!seen[$2]++ {print $0}' | sort -u
systemctl status | cpipe | less -R
systemctl status $( systemctl list-unit-files --type=service|grep able|awk -F'.service' '{print $1}'|pipemenu1) 
systemctl --all --type=service
systemctl list-unit-files
systemctl list-unit-files --type=service
systemctl list-unit-files --type=service | grep varFIND
systemctl list-unit-files --type=service --state=enabled 
systemctl list-unit-files --type=service --state=disabled
# daemon start stop enable // firewall port open
systemctl start varDAEMON && systemctl enable varDAEMON
systemctl stop varDAEMON && systemctl disable varDAEMON
systemctl status varDAEMON
firewall-cmd --permanent --add-service=varDAEMON__ssh
firewall-cmd --reload
# daemon on/ off app
sysv-rc-conf || ay sysv-rc-conf
systemctl-ui || yy systemctl-ui
ntsysv || yy ntsysv
# 
cd /etc/systemd/system; ls -al ;read x ; explorer /etc/systemd/system/
cd /etc/rc.d/init.d/; ls -al ;read x; explorer /etc/rc.d/init.d/
# target mode
systemctl get-default
!!! systemctl set-default multi-user.target
!!! systemctl set-default graphical.target
!!! systemctl isolate graphical.target





%%% 패키지 관리 yum/apt [a] etc (aa)
%% echo -n "Able:" ; { which yum ; which dnf ; which apt ; which pkginfo ; which dpkg ; which rpm ; } 2>/dev/null | tr "\n" " " ; echo
# yum ####################################
yum install -y varPACKAGE
!!! yum -y remove varPACKAGE
yum list updates |less -R 
yum update -y
# 
yum list installed|less -R
yum list varPACKAGE* 
# search && install
yum search varPACKAGE 
yum install -y "$( yum search varPACKAGE|awk -F: '{print $1}' |grep varPACKAGE |pipemenu)"
# search installed PACKAGE
yum whatprovides $(which varCOMMAND)
repoquery -qf */varCOMMAND
rpm -qf $(which varCOMMAND)
rpm -qa | grep varPACKAGE
rpm -ql varPACKAGE
# apt ###################################
apt install -y varPACKAGE
!!! apt remove varPACKAGE
apt update -y && apt upgrade -y
# 
dpkg -L varPACKAGE
# search command and install
apt-file search varCOMMAND | grep 'bin/'
apt install "$(apt-file search varCOMMAND|grep "/varCOMMAND$"|awk -F: '{print $1}'|seen|pipemenu1cancel)"
# search installed PACKAGE
dpkg -S $(which varCOMMAND)
dpkg-query -S varPATH
#
# apm check
yum list installed| grep -E "php|mysql|apache|httpd"|sort
apt list --installed| grep -E '^php[0-9]|^mysql|^apache|httpd'|sort
pkginfo -l|grep -E "apache|mysql|php|httpd"|sort
rpm -qa|egrep -E "php|mysql|apache|httpd"|sort
# install
apt install -y lynx screen bat at net-tools apt-file && apt-file update
yum install -y yum-utils
yum install epel-release && yum repolist && yum update
vi2 $( ls -1 /etc/apt/sources.list /etc/yum.conf 2>/dev/null |pipemenu1 ) 
explorer $( ls -1d /etc/apt /etc/yum.repos.d yum 2>/dev/null |pipemenu1 )




%%% 사용자 관리 [u]
useradd varUSER ; passwd varUSER
passwd varUSER
# id/pw 인증체크
idpw varID varPW varHOST__localhost varPORT__22
# group
groupadd varGroup
# del
!!! userdel varUSER
!!! groupdel varGroup
# usermod id-add
cat /etc/group|grep  "," ;; usermod -aG varGroup__sudo varSudoUSER
# 퍼미션/소유권 
chown varUSER:varGroup varFILE
chmod varPerm varFILE
# 인증 제한 
passwd -l varLockUSER
passwd -u varUnlockUSER
pam_tally2 --user varID --reset
# 
vi2 "$( echo "/etc/passwd /etc/shadow /etc/group /etc/pam.d/password-auth" | pipemenu )"
# 유저계정 확인 
awk -F: '$3 > 99' /etc/passwd
# 잠긴계정 확인
awk -F: 'BEGIN { while (getline < "/etc/passwd") if ($3 > 999) uid[$1]=1 } { if ($2 ~ /^!/ && uid[$1]) print $1 }' /etc/shadow
[ -f /etc/passwd.merged ] && awk -F: '($3 > 999) && ($2 ~ /^[\*!]/) {print $1}' /etc/passwd.merged
# passwd.merged 생성
sh -c 'cp /etc/passwd /etc/passwd.bak && cp /etc/shadow /etc/shadow.bak && pwunconv && cp /etc/passwd /etc/passwd.merged && pwconv && chmod 600 /etc/passwd.merged && chown root:root /etc/passwd.merged'
# install
yyay expect





%%% 시스템 로그 / 열린파일 관리 [l]
%% echo "find /var/log/ -maxdepth 1 -type f -mmin -60"
%% echo $(find /var/log/ -maxdepth 1 -type f -mmin -60)
dmesg | less
journalctl
journalctl -b	# booting log
journalctl -b -1 # booting -1 log
journalctl --since "1 hour ago"
journalctl --since "1 days ago"
journalctl --since "7 days ago"
journalctl _COMM=varPNAME__cron --since "12 hours ago" | cpipe | less -R +G
journalctl -r -p $( echo "info warning err" |pipemenu ) |cpipe|less -R
journalctl -xe | cpipe|less -R # 문제가 발생한 부분과 부가 정보를 포함한 로그
tac /var/log/syslog |cpipe|less -R
tac /var/log/pveam.log |cpipe|less -R
tac /var/log/cron |cpipe|less -R
tac /var/log/auth.log |cpipe|less -R 
tac /var/log/daemon.log |cpipe|less -R
tac /var/log/kern.log |cpipe|less -R
tac /var/log/messages |cpipe|less -R
( trap 'return' SIGINT ; tail -f /var/log/messages )
tac /var/log/secure |cpipe|less -R
tac /var/log/maillog |cpipe|less -R
( trap 'return' SIGINT ; tail -f /var/log/maillog |cpipe )
tac /var/log/httpd/access_log |cpipe|less -R
tac /var/log/httpd/error_log |cpipe|less -R
explorer /var/log/
# 
# List open files
lsof -i		 | cpipe
lsof -i tcp  | cpipe
lsof -i udp  | cpipe
# port
lsof -i:varPort__22 | cpipe
lsof -i:varPort__23 | cpipe
lsof -i:varPort__25 | cpipe
lsof -i:varPort__80 | cpipe
for pid in $(lsof -i:varPort | awk 'NR>1 {print $2}'); do ps -p $pid -o pid,user,%cpu,%mem,comm,args; done | cpipe
# path
lsof +D varPATH__@@etc@@ | cpipe 
lsof +D varPATH__@@root@@ | cpipe 
lsof +D varPATH__@@script@@ | cpipe 
# install
yyay lsof 





%%% 네트워크 관리 [n] / DDoS 점검 (d)
%% hostname; [ ! -f /tmp/go_route.txt ] && route > /tmp/go_route.txt && chmod 600 /tmp/go_route.txt ; cat /tmp/go_route.txt |awk 'NR>1 1' 
%% echo;echo "local_ip_v4:$localip // public_ip_v4:$publicip"
# ip setting
vi2 $( ls -1 /etc/sysconfig/network /etc/sysconfig/network-scripts/ifcfg-* /etc/network/interfaces /etc/resolv.conf /etc/hosts /etc/sysctl.conf /etc/udev/rules.d/70-persistent-net.rules  2>/dev/null |pipemenu1 )
# ubuntu netplan
!!! template_copy netplan.yml varYML__@@etc@@netplan@@01-netplan.yml ; vi2 varYML__@@etc@@netplan@@01-netplan.yml
vi2 $( find /etc/netplan -type f 2>/dev/null |pipemenu1 )
netplan $( echo try apply | pipemenu )
# 
!!! systemctl restart networking 
!!! systemctl restart network
!!! /etc/init.d/network restart
# 
ping varHOST__168.126.63.1
traceroute varHOST__google.com || yyay traceroute
{ ip a ; echo ; ip a |gipa ; echo ; ip a | gip2 ; echo ; ip a | gip2 | awknr2; } |cip
ifconfig -a |cip
route |cip
# 10초간 네트워트 사용량 합산후 출력 
iftop -n -P -t -s varSec__10
iftop -n -P -t ; stty sane
stdbuf -oL iftop -n -P -t -L5 | cip24
# firewall / iptables
!!! ufw $(echo "enable disable"|pipemenu)
!!! iptables -F
iptables-save > /root/_iptables_save.$(datetag2) && tail /root/_iptables_save.$(datetag2)
iptables -L -v -n |grep varIP
# dig
echo -e "dig varHOST ; dig varHOST mx |cip \n dig varHOST @varDNS__168.126.63.1 mx |cip \n" |pipemenulist
# 접속한 내 아이피 확인 
who am i|awk -F'[():]' '{print $3}'
# interface
ip link show | awk -F ': ' '/^[0-9]+:/ {gsub(/:$/, "", $2); if ($2 != "lo") print $2}'
# 서버 공인 아이피 확인
curl -s icanhazip.com || wget -qO- icanhazip.com || curl -s checkip.amazonaws.com
# nmtui network-manager 
nmtui || yyay network-manager net-tools NetworkManager-tui wget curl 
# subnetcalc 
subnetcalc varIPCIDR__192.168.0.1@@26 || yyay subnetcalc
# ipv6 off
echo -e "net.ipv6.conf.all.disable_ipv6 = 1\nnet.ipv6.conf.default.disable_ipv6 = 1\nnet.ipv6.conf.lo.disable_ipv6 = 1\n" >> /etc/sysctl.conf && vi2 /etc/sysctl.conf && sysctl -p


%%% {submenu_hid}DDoS 공격 관리 [d]
# IP 추출/차단시 제외할 아이피 목록을 설정 (/tmp/go_exceptips.private.txt or go.env)
# ex) 127.0.0.0|123.123.123.0|255.255.255.0
%% nobanip="127.0.0.0|61.111.255.0|61.111.254.0|210.118.193.0" ; ( [ -s /tmp/go_exceptips.private.txt ] && cat /tmp/go_exceptips.private.txt || echo "$nobanip" ) | tr '|' '\n' > /tmp/go_exceptips.txt ; chmod 600 /tmp/go_exceptips.txt
%% [ ! -f /tmp/go_route.txt ] && route > /tmp/go_route.txt && chmod 600 /tmp/go_route.txt ; cat /tmp/go_route.txt | awk '{while(match($0, /[0-9]+\.[0-9]+\.[0-9]+/)) {print substr($0, RSTART, RLENGTH) ".0"; $0 = substr($0, RSTART+RLENGTH)}}' | sort -u >> /tmp/go_exceptips.txt
%% who am i|awk -F'[()]' '{print $2}' | awk -F. '{print $1"."$2"."$3".0"}' >> /tmp/go_exceptips.txt
%% grep -v '^\s*$' /tmp/go_exceptips.txt | sed -e 's/\([0-9]*\.[0-9]*\.[0-9]*\.\)[0-9]*/\1/' > /tmp/go_exceptips_grep.txt ; chmod 600 /tmp/go_exceptips_grep.txt # 아이피세자리 
%% echo "Exceptips(/24): $(cat /tmp/go_exceptips.txt|grep -v '^\s*$'|sort -u|tr "\n" " ")"
# 아이피 랭킹 port 22~25 / 53 / 80 ---> ip & port count
na="$(netstat -anp)" ; { echo "$na" | gip | eip5 | sort -k5 ; echo ; ip_ranking="$(echo "$na" | awk '($4 ~ /:(443|80|22|23|24|25|53)$/) && ($5 ~ /:/) { split($4, svr_ip_port, ":"); split($5, ip_port, ":"); if (ip_port[2] > 999) { split(ip_port[1], ip_parts, "."); print ip_parts[1] "." ip_parts[2] "." ip_parts[3] ".0", svr_ip_port[2] } }' | sort | uniq -c| sort -nr | eip )" ; sorted_ip_ranking="$(echo -e "$ip_ranking" | sort -k2)" ; paste <(echo -e "$ip_ranking") <(echo -e "$sorted_ip_ranking") | column -t ; } | cip16
# 제한치(hit) 보다 상회하는 아이피 추출 ( >= $hit )
hit=varHIT ; netstat -anp | awk '($4 ~ /:(443|80|22|23|24|25|53)$/) && ($5 ~ /:/) { split($5, ip_port, ":"); if (ip_port[2] > 999) { split(ip_port[1], ip_parts, "."); print ip_parts[1] "." ip_parts[2] "." ip_parts[3] ".0" } }'|sort|eip|uniq -c|sort -nr | awk -v hit=$hit '{if($1>=hit) print $2}' > /tmp/go_ddosips.txt ; chmod 600 /tmp/go_ddosips.txt ; cat /tmp/go_ddosips.txt | tee /dev/tty | sed -e 's/.0$/./g' > /tmp/go_ddosips_grep.txt ; chmod 600 /tmp/go_ddosips_grep.txt
# 추출 아이피 차단 (추출한지 5분 이내)
!!! [ -s /tmp/go_ddosips.txt ] && [ "$(find /tmp/go_ddosips.txt -mmin -5)" ] && for i in $( cat /tmp/go_ddosips.txt ) ; do echo "iptables -A INPUT -s ${i%/*}/24 -j DROP" ; done > /tmp/go_ddosipsban.txt && for i in $( cat /tmp/go_ddosips.txt ) ; do echo "iptables -D INPUT -s ${i%/*}/24 -j DROP" ; done > /tmp/go_ddosipsbanrev.txt && chmod 600 /tmp/go_ddosipsban.txt /tmp/go_ddosipsbanrev.txt && echo && bash /tmp/go_ddosipsban.txt && echo ">>> 차단완료" &&  cat /tmp/go_ddosipsban.txt && echo ">>> 방화벽 차단내역 조회" && iptables -L -v -n |awk 'BEGIN{RS=""} /Chain INPUT \(policy/' |tail -n20 | grep -Ef /tmp/go_ddosips.txt
# 추출한 아이피 whois 조회 
for i in $( cat /tmp/go_ddosips.txt ) ; do echo "$i" ; whois -h whois.nic.or.kr $i ; readx ; echo ; done 
# 추출 아이피 차단 해제 
bash /tmp/go_ddosipsbanrev.txt && echo -e  ">>> 해제완료" && cat /tmp/go_ddosipsbanrev.txt
# 최근 차단 아이피 조회 // 추출 아이피 차단 조회
iptables -L -v -n |awk 'BEGIN{RS=""} /Chain INPUT \(policy/' |tail -n20 | gip | cip
iptables -L -v -n |awk 'BEGIN{RS=""} /Chain INPUT \(policy/' |tail -n20 | grep -Ef /tmp/go_ddosips.txt | gip | cip
# 예외 설정 아이피 확인 
cat /tmp/go_exceptips.txt ; echo ; cat /tmp/go_exceptips_grep.txt ; 
# 아이피 수동 차단 (다수 아이피 가능) 
ips="varIPS" ;"$( echo ipban ipban24 ipban16 | pipemenu )" $ips
# 아이피 수동 해제 (다수 아이피 가능)
iptables -L -v -n | tail -n20 | gip | cip16 ;; "$( echo ipallow ipallow24 ipallow16 | pipemenu )" "varIPS"
# 웹로그 server-status // dom sort
while :; do weblog | sed -e 's/www\.//g' -e '/NULL/d' | awk '{print $12,$11,$0}' | sort -k1,2 | cut -d' ' -f 3- | gip|eip|cip24 ; echo ; printf "5초후 리프래시 or 종료시 -> [Enter] " && read -t5 -n1 x && break ; echo ; done
# 웹로그에서 추출 아이피 검색 및 차단
weblog | sed -e 's/www\.//g' -e '/NULL/d' | awk '{print $12,$11,$0}' | sort -k1,2 | cut -d' ' -f 3- | gip|eip|cip16 |grep -Ef /tmp/go_ddosips_grep.txt
weblogresult="$(weblog | sed -e 's/www\.//g' -e '/NULL/d' | awk '{print $12,$11,$0}' | sort -k1,2 | cut -d' ' -f 3- | gip|eip|cip16 |grep -Ef /tmp/go_ddosips_grep.txt)" ; echo -e "$weblogresult" ; ipban24 "$(echo "$weblogresult" | awk '{print $11}'| noansi| seen |pipemenu1cancel)" 



%%% 파일시스템 관리 [f] / LVM (lvm)
mount | cpipe
# mount all from fstab
vi2 /etc/fstab
mount -a
df -h | cper
fdisk -l | cpipe ;; parted -l | cpipe ;; lsblk ; echo ; blkid 
fdisk -l /dev/varHDD 
fdisk /dev/varHDD
blkid | grep varFIND
blkid /dev/varHDD
# uuid 참조하여 fstab 에 추가할수 있게 파티션 양식 추가 (주석으로 추가) 
cat /etc/fstab ;; blkid ;; blkid2fstab /dev/varPARTITION /varDIR && vi2 /etc/fstab
# mkfs
!!! fdisk -l ;; "$( ls -1 /usr/sbin/mkfs* |pipemenu1 )" /dev/varPARTITION
# mkfs.ext4 all Linux partition
!!! fdisk -l ;; echo ; mkfs.ext4 $(fdisk -l /dev/varHDD|grep Linux$|awk '{print $1}' |pipemenu1)
# umount /tmp force
!!! fuser -km /tmp ; umount /tmp
# pid kill -> fsck
!!! df ;; fuser -km /varMountDIR ; umount /varMountDIR ; e2fsck -jp -y /dev/varPATITION ; mount /dev/varPARTITION /varMountDIR ;
!!! umount /dev/varPARTITION ; e2fsck -jp -y /dev/varPARTITION
# hdd speed test
hdparm -t /dev/varHDD
# Liuux 파티션 모두 마운트 /dev/sdb1 -> /mnt/sdb1 형태로 자동마운트
for i in $( fdisk -l /dev/varHDD|grep Linux$|awk '{print $1}'|awk -F/ '{print $3}' ); do mkdir /mnt/$i; mount /dev/$i /mnt/$i; done ; df
# growpart /dev/sda 3 -> 3번 파티션 확장 
!!! growpart /dev/varDEV varPARTNO || ay cloud-guest-utils
# fdisk -> reboot -> resize2fs /dev/sda3
!!! resize2fs /dev/varPARTNO
# swap {1,2,4,8}G on / off
df ; free ; echo ; cat /proc/swaps ;; size=$( echo 1024000 2048000 4096000 8192000 | pipemenu ) ;; dd if=/dev/zero bs=1024 count=$size | { pv -s ${size}k || cat ; } > varSwapPath__@@backup@@extra_swap ; mkswap varSwapPath__@@backup@@extra_swap $size ; swapon varSwapPath__@@backup@@extra_swap ; chmod 600 varSwapPath__@@backup@@extra_swap ; free ; echo ; cat /proc/swaps
# swap on -> rc.local service add
cat /proc/swaps ;; [ -f /etc/rc.local ] && echo "[ -f varSwapPath__@@backup@@extra_swap ] && swapon varSwapPath__@@backup@@extra_swap" >> /etc/rc.local && vi2 /etc/rc.local
# swap off 
free ; echo ; cat /proc/swaps ;; swapoff varSwapPath__@@backup@@extra_swap && rm -rf varSwapPath__@@backup@@extra_swap ; free ; echo ; cat /proc/swaps
# 파티션 복구 -> testdisk // yyay testdisk 





%%% 시스템 초기설정과 기타 [i]
{submenu_sys}










%%% 로컬백업 [b] / 원격백업 (bb)
mkdir -p varBackupDIR__@@backup ; chmod 700 varBackupDIR__@@backup
# etc backup
rbackup /etc/passwd /etc/shadow /etc/group /etc/crontab /etc/named.conf /etc/fstab /etc/hosts 
# /etc /root 압축백업 
rbackup varBackupDIR__@@backup/etc_daily.tgz ; tar cvzf varBackupDIR__@@backup/etc_daily.tgz /etc/ 
rbackup varBackupDIR__@@backup/root_daily.tgz ; tar cvzf varBackupDIR__@@backup/root_daily.tgz --exclude=/root/.cache /root/
# 지정폴더 압축백업 
f="$(basename varDestFolder)" ; rbackup varBackupDIR__@@backup/$f.tgz ; tar cvzf varBackupDIR__@@backup/$f.tgz varDestFolder ; ls -al varBackupDIR__@@backup/$f.tgz 
#
# rsync 증분백업 로컬 (삭제/변경된파일 원본유지) 백업본1,백업본7*24
# cron 에 삽입시에는 % 앞에 역슬래시 추가 
rsync -ar --backup --suffix=.bak --exclude='varExclude__@@.err@@' varSource__@@home varBackupDIR__@@backup@@
rsync -ar --backup --suffix=.bak_$(date +%w%H) --exclude='varExclude__@@.err@@' varSource__@@home varBackupDIR__@@backup@@
# rsync 동기화백업 로컬
rsync -ar --delete --exclude='varExclude__@@.err@@' varSource__@@home varBackupDIR__@@backup@@
# rsync 증분백업 로컬->원격(압축전송) // (삭제/변경된파일 원본유지)
rsync -arz --backup --suffix=.bak --exclude='varExclude__@@.err@@' varRhost:varSource__@@home varBackupDIR__@@backup@@
rsync -arz --backup --suffix=.bak_$(date +%w%H) --exclude='varExclude__@@.err@@' varRhost:varSource__@@home varBackupDIR__@@backup@@
# rsync 동기화백업 로컬->원격(압축전송)
rsync -arz --delete --exclude='varExclude__@@.err@@' varSource__@@home varRhost:varBackupDIR__@@backup@@
#
# lftp 증분백업 로컬->원격 (s?ftps?,https?,fish,torrent)
lftp -u varUsername,varPassword ftp://varRhost -e "set ftp:list-options -a; lcd varSource__@@home; cd varBackupDIR__@@backup@@home ; mirror --exclude-glob varExclude__@@.err@@ ; bye"
# lftp 동기화백업 로컬->원격 
lftp -u varUsername,varPassword ftp://varRhost -e "set ftp:list-options -a; lcd varSource__@@home; cd varBackupDIR__@@backup@@home ; mirror --delete --exclude-glob varExclude__@@.err@@ ; bye"
#
# dbs all dump
mkdir -p varBackupDIR__@@backup@@mysqldump/ ; for i in $(mysql -Be "show databases;" | awk 'NR>1'); do echo "$i DB dumping..." ; mysqldump -Q $i | gzip > varBackupDIR__@@backup/${i}.$(datetag1).sql.gz; done ;  chmod 600 varBackupDIR__@@backup@@mysqldump/*.sql.gz
# dbs all dump // week rotate
mkdir -p varBackupDIR__@@backup@@mysqldump/ ; for i in $(mysql -Be "show databases;" | awk 'NR>1'); do echo "$i DB dumping..." ; mysqldump -Q $i | gzip > varBackupDIR__@@backup/${i}.$(datetagw).sql.gz; done ;  chmod 600 varBackupDIR__@@backup@@mysqldump/*.sql.gz
#
yyay lftp rsync



%%% {submenu_hidden}원격 백업 관리 [bb]
# 원격지 홈폴더 select 백업 (ncp) // pv 진행바 // zstd 네트워크 효율 좋음 
list="$( ssh varRhost "find / -maxdepth 2 -type d \( -regex \"/home[^/]*\" -o -regex \"/home.*/.*\" \)" )" ; d="$(echo "$list"|pipemenu1cancel)" ; [ "$d" ] && [[ ! "$d" == *Cancel* ]] && { echo -n "Execute: ncp varRhost $d varLocalBackupPath varPORT__22 [Enter] " && read x && mkdir -p varLocalBackupPath && time ncp varRhost $d varLocalBackupPath varPORT__22 && ls -al varLocalBackupPath ; }
# 
# 원격지 선택 폴더 하부의 숨김폴더 제외 하고 각각 백업 ex) /home/{all but .hide} 
# 제외할 폴더 다수개 입력 가능 var1 var2 -> */var1* */var2*
# 로컬에 복사할 폴더가 있는 경우 skip (이어받기 가능)
pwd;; h="varRHOST"; d="varRBackupFolderPath"; l="varLocalBackupPath"; except="varExcept__except_path_here"; except="$(echo "$except" | xargs -n1 printf "! -path '*/%s*' ")" ; mkdir -p $l$d; [ "$d" ] && list="$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $h "find $d -maxdepth 1 -mindepth 1 -type d ! -path '*/\.*' ! -path '*/lost+found*' $except |sort ")"; [ "$list" ] && list="$( realpathf $list )" && { echo -n "list : " ; echo $list ; echo ; total_count="$(echo "$list" | wc -l)"; count=1; for i in $list ; do [ ! -d $l$i ] && { CYN ; echo "[$count/$total_count] $i copying... " && ncp $h $(realpathf $i) $l$d varPORT__22 ; } || { RED1 ; echo "[$count/$total_count] $i skipped... " ; } ; count=$((count+1)); echo ; done ; } ; cd $l
#
# 로컬 압축파일로 저장 // 기존재 파일 skip 지원 // ex) /home 계정별로 전체 압축하고 싶을때 
pwd;; h="varRHOST"; d="varRBackupFolderPath"; l="varLocalBackupPath"; except="varExcept__except_path_here"; except="$(echo "$except" | xargs -n1 printf "! -path '*/%s*' ")" ; mkdir -p $l$d; [ "$d" ] && list="$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $h "find $d -maxdepth 1 -mindepth 1 -type d ! -path '*/\.*' ! -path '*/lost+found*' $except |sort ")"; [ "$list" ] && list="$( realpathf $list )" && { echo -n "list : "; echo $list; echo; total_count="$(echo "$list" | wc -l)"; count=1; for i in $list; do [ ! -f "${l}${d}/$h.$(basename "$i").tar.zst" ] && [ ! -f "${l}${d}/$h.$(basename "$i").tgz" ] && { CYN ; echo "[$count/$total_count] $i copying... " && ncpzip $h $(realpathf $i) $l$d varPORT__22 ; } || { RED1 ; echo "[$count/$total_count] $i skipped... " ; } ; count=$((count+1)); echo; done ; } ; cd $l 
#
# 업데이트된 파일만 추가 백업 // 기존 백업 tar.zst or tgz 파일을 참조함 
pwd;; h="varRHOST"; d="varRBackupFolderPath"; l="varLocalBackupPath"; except="varExcept__except_path_here"; except="$(echo "$except" | xargs -n1 printf "! -path '*/%s*' ")" ; mkdir -p $l$d; [ "$d" ] && list="$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $h "find $d -maxdepth 1 -mindepth 1 -type d ! -path '*/\.*' ! -path '*/lost+found*' $except |sort ")"; [ "$list" ] && list="$( realpathf $list )" && { echo -n "list : "; echo $list; echo; total_count="$(echo "$list" | wc -l)"; count=1; for i in $list; do [ -f "${l}${d}/$h.$(basename "$i").tar.zst" ] || [ -f "${l}${d}/$h.$(basename "$i").tgz" ] && { CYN ; echo "[$count/$total_count] $i update checking... " && ncpzipupdate $h $(realpathf $i) $l$d varPORT__22 ;RST; } || { RED ; echo "[$count/$total_count] $i skipped... ";RST ; } ; count=$((count+1)); echo; done ; } ; cd $l ; find ./ -type f -size 0 -exec rm {} \;

#
ncp varRemoteHOST varRemotePATH varLocalPATH varPORT__22 ; explorer varLocalPATH
ncpr varLocalPATH varRemoteHOST varRemotePATH varPORT__22 ; 
ncpzip varRemoteHOST varRemotePATH varLocalPATH__@@backup varPORT__22 ;
ncpzipupdate varRemoteHOST varRemotePATH varLocalPATH__@@backup varPORT__22 ;
# 하드 I/O (df) && process monitor 
dfmonitor
#




%%% 클라우드 관리 [c] / rclone (cc)
# ncp 서버간 압축(tar/zstd) 전송(ssh) 함수 
# ncp(원격지파일폴더->로컬로복사)// ncpr(로컬파일폴더->원격지서버로복사)// ncpzip(tgz저장)
ncp varRemoteHOST varRemotePATH varLocalPATH varPORT__22 ; push ; explorer varLocalPATH
ncpr varLocalPATH varRemoteHOST varRemotePATH varPORT__22 ; push
ncpzip varRemoteHOST varRemotePATH varLocalPATH__@@backup varPORT__22 ; push
ncpzipupdate varRemoteHOST varRemotePATH varLocalPATH__@@backup varPORT__22 ; push
#
# 원격지(ssh) 폴더를 로컬 폴더로 마운트 (sshfs:sftp)
[ ! -d /mnt/varLocalDIR__sshfs.mount ] && mkdir -p /mnt/varLocalDIR__sshfs.mount; sshfs root@varRHOST:varRDIR /mnt/varLocalDIR__sshfs.mount -pvarSshPort__22; df |grep /mnt 
#
# nfs mount 
mkdir -p /mnt/varLocalDIR__nfs.mount ; mount -t nfs -o nolock varRHOST:varRDIR/ /mnt/varLocalDIR__nfs.mount
# smb mount
mkdir -p /mnt/varLocalDIR__smb.mount ; mount -t cifs -o "username=varSMBusername,password=varSMBpassword" "//varSMBhost/varRDIR/" /mnt/varLocalDIR__smb.mount
#
# nfs fstab add
echo "# varRHOST:varRDIR/ /mnt/varLocalDIR__nfs.mount nfs nolock,_netdev 0 0" >> /etc/fstab && vi2 /etc/fstab
# smb fstab add
echo "# //varSMBhost/varRDIR/ /mnt/varLocalDIR__smbmount cifs credentials=/root/.smbcredentials,noperm,_netdev 0 0" >> /etc/fstab && vi2 /etc/fstab
echo -e "username=varSMBusername\npassword=varSMBpassword" >> /root/.smbcredentials && vi2 /root/.smbcredentials
#
# ssh 블록복사 (-> 함수로 만든것 ncp)
h="varRhost" ; f="varRpath" ; l="varLocalPath" ; d="$(dirname $f)" ; dest=${f/$d\//}; echo -n "원격지 $h 의 폴더 $d 안의 ./$dest 가 $l 안으로 복사 [Enter] "|sed -e 's|//|/|g'  && read x && { [ ! -d $l ] && mkdir -p $l ; ssh $h "cd $d ; tar czfp - ./$dest" | tar xzf - -C $l && explorer $l ; }
# 
# 언마운트 /mnt/MountPoint
df |grep "/mnt" ;; umount $(df |grep /mnt|awk99|pipemenu1) ; df|grep mnt
# install
yyay sshfs fuse zstd fuse pv smbclient
yy nfs-utils || ay nfs-common




%%% {submenu_sys}한글화 / 타임존 / 모듈설정 [han]
# LANG 
env ; echo $LANG ; locale
locale -a
# apt
ay locales  
vi2 /etc/locale.gen
locale-gen varLocale__ko_KR.UTF-8
update-locale
# centos
# 기본 locale 변경후 재접속시 반영 
localedef -i ko_KR -f UTF-8 ko_KR.UTF-8
localectl set-locale LANG=ko_KR.UTF-8
# 
rbackup ; sed -i '/LANG=.*$/c\LANG=ko_KR.UTF-8' /etc/default/locale ; vi2 /etc/default/locale
echo "LC_MESSAGES=ko_KR.UTF-8" >> /etc/default/locale ; vi2 /etc/default/locale
echo "_JAVA_OPTIONS=\"-Duser.timezone=Asia/Seoul\"" >> /etc/environment ; vi2 /etc/environment
vi2 "$( echo "/etc/default/locale /etc/sysconfig/i18n /etc/profile.d/tmout.sh /etc/environment"|pipemenu )"
# timezone
timedatectl 
timedatectl set-timezone Asia/Seoul ; date
hostnamectl ;; hostnamectl set-hostname varNEWHostName
rdate -s zero.bora.net && hwclock --systohc
rdate -s time.nist.gov && hwclock --systohc
tzselect
date
echo $(date "+%Y%m%d.%H%M%S")
echo $(date "+%Y%m%d.%H%M%S")$(($RANDOM%9000+1000))
#
vi2 "$( echo "/etc/hosts /etc/sysconfig/hwconf /etc/modules.conf /etc/modprobe.d/modprobe.conf" |pipemenu )"
vi2 "$( echo "/etc/fstab /etc/rc.d/rc.local /etc/crontab /etc/motd /etc/resolv.conf"|pipemenu)"
vi2 "$( echo "/root/.vimrc /root/.bashrc"|pipemenu)"
#
lspci
lshw | cpipe | less -R
lsmod
modprobe varA
insmod varA
kudzu
explorer /etc/




%%% {submenu_sys}환경변수 설정 [en]
%% echo "TERM: $TERM"
env
# 운용서버에서 환경파일 가져오기
scp varHOST:/root/.bashrc /root/
vi2 /root/.bashrc
# 서버 모니터 tty1 로 커널 메세지 출력 -> 레벨 조절 
cat /proc/sys/kernel/printk
# 경고 이상만 출력(임시/영구)
echo "3 4 1 7" > /proc/sys/kernel/printk
echo "kernel.printk = \"3 4 1 7\"" >> /etc/sysctl.conf
# PS1 터미널 창제목 고정 
echo "PS1='\[\033]0;\u@\h:\w\a\] '\$PS1" >> ~/.bashrc
# 사용자가 직접 로그인한 경우에만 소스 {불러오기,실행,!break} (scp//sftp제외)
sed -i '1i [[ $- != *i* ]] && return' ~/.bashrc
echo "[[ \$- == *i* ]] && source varSourcePATH" >> ~/.bashrc
echo "[[ \$- == *i* ]] && varCommand" >> ~/.bashrc
#
# PS1 프롬프트 설정
export PS1="\[\033[1;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]$ "
export PS1="\n\033[1;33m\t \d \033[0m\033[0;32m[\u@\h \w]\033[0m\n\\$ "
# 프롬프트 적용
echo 'PS1="\[\033[1;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]$ "' >> /root/.bashrc ; vi2 /root/.bashrc
echo 'PS1="\n\033[1;33m\t \d \033[0m\033[0;32m[\u@\h \w]\033[0m\n\\$ "' >> /root/.bashrc ; vi2 /root/.bashrc
# 멀티라인 프롬프트 설정
export PS2=">"
# PS3 셀렉트 프롬프트 설정
export PS3="Select No. : "
# PS4 디버그 모드 프롬프트 설정
export PS4="+ Line \$LINENO: " ; set -x 
#
# ssh sha1 err in alma
update-crypto-policies --set DEFAULT:SHA1



%%% {submenu_sys}셋업 보안 관리 [se]
# file perm
chmod 700 /usr/bin/chage /usr/bin/wall /usr/bin/write /bin/dd /bin/mount /bin/umount /bin/rpm /usr/bin/finger
chmod 700 /usr/bin/top /usr/bin/uptime /usr/bin/whereis /usr/bin/which /usr/bin/lwp-download /usr/bin/nslookup /usr/bin/lsof
chmod 700 /usr/bin/cc /usr/bin/gcc /usr/bin/make /usr/bin/pstree /usr/bin/rlogin /usr/bin/rlog /bin/mount /bin/umount
# wheel perm
chmod 750 /bin/ps /bin/netstat /bin/dmesg /bin/df /usr/bin/who /usr/bin/finger /usr/bin/last /usr/bin/lastlog /usr/bin/top /usr/bin/w /bin/uname
chgrp wheel /bin/ps /bin/netstat /bin/dmesg /bin/df /usr/bin/who /usr/bin/finger /usr/bin/last /usr/bin/lastlog /usr/bin/top /usr/bin/w /bin/uname
#
cat /etc/group|grep  "," ;; usermod -aG varGroup__wheel varSudoUSER
# folder perm
chmod 711 / /dev /etc /home* /initrd /lib /var/log /var/log/httpd /var /usr
chmod 700 /boot /mnt /root
# service folder create
mkdir -p /backup /ban /script /scriptuser /homein/expire /home1/expire /home/expire
chmod 700 /backup /ban /script /home1/expire /homein/expire /home/expire
#
# 주요 실행 명령 변조대비 백업
[ ! -d /root/bin/ ] && mkdir -p /root/bin/ && cp -a /bin/netstat /usr/bin/top /bin/login /usr/bin/dir /usr/bin/find /usr/bin/pstree /usr/bin/md5sum /bin/ls /bin/ps /sbin/ifconfig /root/bin/ && chattr +i /root/bin/
[ ! -d /bin.backup ] && cp -a /bin/ /bin.backup && chmod 700 /bin.backup && chattr +i /bin.backup
[ ! -d /sbin.backup ] && cp -a /sbin/ /sbin.backup && chmod 700 /sbin.backup && chattr +i /usr/bin.backup
[ ! -d /usr/bin.backup ] && cp -a /usr/bin/ /usr/bin.backup && chmod 700 /usr/bin.backup && chattr +i /usr/bin.backup



%%% {submenu_sys}서버 웹관리 솔루션 설치 (webmin/perl)
%% echo "https://$publicip:10000" ; [ "$publicip" == "$(hostname -i)" ] && echo "https://$(hostname):10000"
# webmin_ubuutu repo
curl -s http://www.webmin.com/jcameron-key.asc | apt-key add -
add-apt-repository "deb [arch=amd64] http://download.webmin.com/download/repository sarge contrib" || ay software-properties-common && add-apt-repository "deb [arch=amd64] http://download.webmin.com/download/repository sarge contrib"
# webmin_centos repo
curl -O http://www.webmin.com/jcameron-key.asc
rpm --import jcameron-key.asc
vi2 /etc/yum.repos.d/webmin.repo
printf "[Webmin] \nname=Webmin Distribution Neutral\nbaseurl=http://download.webmin.com/download/yum\nenabled=1\ngpgcheck=1\ngpgkey=http://www.webmin.com/jcameron-key.asc" >> /etc/yum.repos.d/webmin.repo
# webmin install
yyay webmin
# firewall port open
ufw allow 10000 || firewall-cmd --add-port=10000/tcp --permanent && firewall-cmd --reload
# website (guide: http://www.webmin.com)
systemctl status webmin
systemctl start webmin && systemctl enable webmin
systemctl stop webmin && systemctl disable webmin






%%% {submenu_sys}서버 웹관리 솔루션 설치 (cockpit/perl)
%% echo https://$publicip:9090 ; [ "$publicip" == "$(hostname -i)" ] && echo https://$(hostname):9090
yy epel-release 
yyay cockpit
# firewall port open
ufw allow 9090
firewall-cmd --add-service=cockpit &&  firewall-cmd --add-service=cockpit --permanent
# centos repo add
curl -O /etc/yum.repos.d/cockpit.repo https://copr.fedorainfracloud.org/coprs/g/cockpit/cockpit-preview/repo/epel-7/group_cockpit-cockpit-preview-epel-7.repo
systemctl start cockpit ; systemctl enable cockpit
# website (guide: https://cockpit-project.org)
dpkg-query -l cockpit-system || yyay cockpit-system
# AllowUnencrypted = true
vi2 /etc/cockpit/disallowed-users
systemctl restart cockpit 
#
systemctl status cockpit
systemctl start cockpit && systemctl enable cockpit
systemctl stop cockpit && systemctl disable cockpit
lsof -i:9090



%%% {submenu_sys}응급 복구 / 시동 [r]
fdisk -l
fdisk -l /dev/varD
fdisk -l ;; fdisk /dev/varD
# mount
vi2 /etc/fstab
mount
mount -a
mount /tmp -o remount,$( echo exec noexec | pipemenu ) 
chmod 1777 /tmp/
# chroot 
mount /dev/varROOTPARTITION /mnt/sysimage
mount /dev/varBOOTPARTITION /mnt/sysimage/boot
!!! chroot /mnt/sysimage
# lilo
vi2 /etc/lilo.conf
!!! lilo
# grub
ls -al /etc/default/ ; explorer /etc/default/
vi2 /etc/default/grub
vi2 /etc/grub.conf
!!! grub
!!! update-grub
# grub2
grub2-mkconfig -o /boot/grub2/grub.cfg
# 현재커널
grubby --default-kernel
# 커널추가
grubby --add-kernel=/boot/vmlinuz-varVER --initrd=/boot/initramfs-varVER.img --title "varTITLE"
# 커널변경
grubby --set-default=/boot/vmlinuz-varVER
# 커널삭제
grubby --remove-kernel=/boot/vmlinuz-varVER
# 
vi2 /root/.bashrc
explorer /boot/








%%% {submenu_sys}file explorer [ex]
ranger || yyay ranger 
lfm || yyay lfm
mc || yyay mc
vifm || yyay vifm
nnn || yyay nnn
# ranger (python stg install)
pip install ranger-fm
# centos6 git ranger install (python2 base)
yy git 
cd /backup ; git clone https://github.com/ranger/ranger.git
cd ranger ; git checkout v1.8.1 ; make install


%%% {submenu_sys}ifcfg-ethx setting [ipset]
# ifcfg-ethx 파일이 없거나, IP (static/dhcp) 갱신이 필요할때 
# centos 기준 작성 
declare -f ifcfgset
ifcfgset
#
explorer /etc/sysconfig/network-scripts/
#
!!! systemctl restart networking
!!! systemctl restart network
!!! service network restart
!!! /etc/init.d/network restart



%%% {submenu_sys}rdiff-backup 롤백지원 백업 [rb]
# backup
rdiff-backup /root /backup/root_rdiff_backup
rdiff-backup /script /backup/script_rdiff_backup
rdiff-backup varLpath varBackupPath
# chg check
rdiff-backup --list-increments /backup/root_rdiff_backup
rdiff-backup --list-increments /backup/root_rdiff_backup|grep "increments."| awk -F. '{print $2}'
rdiff-backup --list-increments varBackupPath
explorer /backup/root_rdiff_backup/rdiff-backup-data/
# restore now(최신) 3D(3일전) 1W(1주전) 2M(2달전)
rdiff-backup --restore-as-of "varAGO" --force /backup/root_rdiff_backup /root
rdiff-backup --restore-as-of "$(rdiff-backup --list-increments /backup/root_rdiff_backup|grep "increments."| awk -F. '{print $2}'|pipemenu)" --force /backup/root_rdiff_backup /root
rdiff-backup --restore-as-of "$(rdiff-backup --list-increments varBackupPath|grep "increments."| awk -F. '{print $2}'|pipemenu)" --force varBackupPath varLpath
# delete 1M (한달지난 백업본 삭제)
rdiff-backup --remove-older-than 1M varBackupPath
# 로컬 디렉터리를 원격 서버에 백업
rdiff-backup varLpath varID__root@varRhost::varBackupPath
# 원격 서버의 디렉터리를 로컬에 복구
rdiff-backup --restore-as-of varAGO__now varID__root@varRhost::varBackupPath varLpath
# cron add example (2am)
echo "#0 2 * * * root rdiff-backup /root /backup/root_rdiff_backup" >> /etc/crontab
#
# install
yyay rdiff-backup



%%% {submenu_sys}Lamp install [lamp]
{submenu_lamp}


%%% {submenu_lamp}Lamp (Rocky,Alma) linux 8/9 [lampc]
# apache install
dnf install -y httpd httpd-tools
systemctl enable httpd ; systemctl start httpd ; systemctl status httpd
firewall-cmd --permanent --zone=public --add-service=http 
firewall-cmd --permanent --zone=public --add-service=https 
firewall-cmd --reload
systemctl restart httpd
# http://IP_address
#
# php install epel repo add
rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm
# alma8 php7.x
dnf module list php
dnf module reset php
dnf module enable php:varVersion
dnf install -y php php-cli php-gd php-curl php-zip php-mbstring php-mysqlnd
# alma9 php8.1
dnf install -y php php-mysqlnd php-dom php-simplexml php-xml php-xmlreader php-curl php-exif php-ftp php-gd php-iconv php-json php-mbstring php-posix php-sockets php-tokenizer
systemctl restart httpd 
php -v 
dnf install -y phpMyAdmin.noarch
vi2 /etc/httpd/conf.d/phpMyAdmin.conf
dnf search php
# http://IP_address/info.php
echo "<?php phpinfo() ?>" > /var/www/html/info.php
# db install
dnf install -y mariadb-server mariadb
systemctl enable mariadb ; systemctl start mariadb ; systemctl status mariadb
mysql_secure_installation
mysql -e "SHOW DATABASES;" -p
# 
ntsysv || yy ntsysv



%%% {submenu_lamp}Lamp (Centos7) linux [lampcc]
# apache install
yum install -y httpd
systemctl enable httpd ; systemctl start httpd ; systemctl status httpd
firewall-cmd --permanent --zone=public --add-service=http
firewall-cmd --permanent --zone=public --add-service=https
firewall-cmd --reload
systemctl restart httpd
# http://IP_address
#
# php
yum install -y php php-mysql
systemctl restart httpd
php -v
# http://IP_address/info.php
echo "<?php phpinfo() ?>" > /var/www/html/info.php
yum install -y phpmyadmin
vi2 /etc/httpd/conf.d/phpMyAdmin.conf
# db install
yum install -y mariadb-server mariadb
mysql_secure_installation
systemctl enable mariadb ; systemctl start mariadb ; systemctl status mariadb
mysql -e "SHOW DATABASES;" -p
#
ntsysv || yy ntsysv


%%% {submenu_lamp}Lamp (Annyung3) linux [lampan3]
# apache install
yum install -y varPkg__httpd
yy httpd mod_ssl
yum search varPkg__httpd --disablerepo='*' --enablerepo="AN:addon" --enablerepo="AN:core" --enablerepo="AN:base" --enablerepo="AN:xless"
yum list varPkg__httpd* |cgrep Installed|cgrep1 Available
yum list installed |grep varPkg__http
systemctl enable httpd ; systemctl start httpd ; systemctl status httpd
chattr +i /etc/httpd/conf/httpd.conf ; vi2 /etc/httpd/conf/httpd.conf
vi2 $( find /etc/httpd/user.d/ -type f | pipemenu )
explorer /etc/httpd/
# http://IP_address
#
# php install
yy php80* --skip-broken
yy php74* --skip-broken
yum list installed|grep php
explorer /etc/$( ls -1 /etc/ |grep php | pipemenu )
systemctl restart httpd
php -v
# http://IP_address/info.php
echo "<?php phpinfo() ?>" > /var/www/html/info.php
# phpmyadmin
yy phpmyadmin
vi2 /etc/httpd/conf.d/phpMyAdmin.conf
yumdownloader phpMyAdmin.noarch
rpms=$(ls -1tr|grep phpMyAdmin|tail -n1) ; rpm -ivh --nodeps $rpms ; readx ; rpm -ql ${rpms%.rpm}
# db install
yum install -y mariadb-server mariadb
mysql_secure_installation
systemctl enable mariadb ; systemctl start mariadb ; systemctl status mariadb
mysql -e "SHOW DATABASES;" -p
# httpd watch
rpm -ql check-utils
/usr/bin/chkbandwidth
/usr/bin/httpwatch http://localhost
vi2 $( echo /etc/cron.d/httpd-monitor /etc/sysconfig/httpd-monitor|pipemenu )
#
ntsysv || yy ntsysv




%%% {submenu_lamp}Lamp (debina/ubuntu) linux [lampd]
# db
apt install -y mariadb-server mariadb-client
mysql_secure_installation 
# apache2
apt install -y apache2 apache2-doc
a2enmod userdir
systemctl restart apache2
# firewalld
apt install ufw
ufw app list
ufw app info "WWW Full"
ufw allow in "WWW Full"
# php / perl / python
apt install -y php libapache2-mod-php php-mysql 
apt install -y perl libapache2-mod-perl2
apt install -y python3 libapache2-mod-python
#
apt install -y phpmyadmin





%%% {submenu_sys}webd ftpd postfix dovecot [dmi]
# apache2
yyay apache2
vi2 /etc/apache2/apache2.conf
explorer /etc/apache2
a2enmod varModule__rewrite
systemctl restart apache2
systemctl status apache2
# nginx
yyay nginx
vi2 /etc/nginx/nginx.conf
explorer /etc/nginx
systemctl restart nginx 
systemctl status nginx
# ftpd
yyay vsftpd
vi2 /etc/vsftpd.conf
systemctl restart vsftpd
systemctl status vsftpd
# maild smtp
yyay postfix 
vi2 /etc/postfix/main.cf 
explorer /etc/postfix/
systemctl restart postfix
systemctl status postfix
# maild pop imap
yyay dovecot-imapd dovecot-pop3d
vi2 /etc/dovecot/dovecot.conf
explorer /etc/dovecot/
systemctl restart dovecot 
systemctl status dovecot 





%%% {submenu_com}nfs server [nfs]
# install
yy nfs-utils rpcbind
ay nfs-kernel-server nfs-common
# share dir create 
export nfsdir="varShareDir__@@nfs.share"
mkdir -p $nfsdir && chmod 777 $nfsdir && touch $nfsdir/.nfs.share.$localip 
# nfs 서버에 접근을 허용할 IP 대역 지정 
# remoteip ex) 192.168.0.1 or 192.168.0.1/24 or 192.168.0.1/16 or *
# 접근권한 ex) no_root_squash / root_squash / no_all_squash / all_squash
echo "#$nfsdir varRemoteIP(rw,sync,no_root_squash)" >> /etc/exports && vi2 /etc/exports
vi2 /etc/exports
# firewall port open 111,2049,20048,32769(tcp/udp) nfs/mountd/rpc-bind
# 
systemctl start nfs && systemctl enable nfs
systemctl status nfs
# apply
exportfs -ra
exportfs -v
showmount -e 
#
vi2 $( ls -1 /etc/sysconfig/nfs /etc/nfs.conf 2>/dev/null | pipemenu1 ) 
#
# client
#
# nfs mount 
mkdir -p /mnt/varLocalDIR__nfs.mount ; mount -t nfs -o nolock varRHOST:/varRDIR/ /mnt/varLocalDIR__nfs.mount
# nfs fstab add
echo "# varRHOST:/varRDIR/ /mnt/varLocalDIR__nfs.mount nfs nolock,_netdev 0 0" >> /etc/fstab && vi2 /etc/fstab



%%% {submenu_com}mysql query [mysql]
mysqlshow
# mysql connect 
mysql varDBNAME
mysql $( mysql -Be "show databases;"|awk 'NR>1' |pipemenu1)
# mysql process monitoring
while true;do echo;date;cat /proc/loadavg;mysqladmin processlist|egrep -v "Sleep|DELAYED";read -s -n1 -t1 key;[ "$key" == 'q' ] && break;sleep 1 ;done
mysqladmin processlist|grep -v "Sleep"
# table query
mysql varDBNAME -e 'show tables;'
mysql varDBNAME -e 'varCOMMAND ;'
mysql $( mysql -Be "show databases;"|awk 'NR>1' |pipemenu1) -e 'varCOMMAND ;'
# table check
export db=$( mysql -Be "show databases;"|awk 'NR>1' |pipemenu1) ; export table="$( mysql $db -Be 'show tables;' |pipemenu1 )" ;; myisamchk -r /var/lib/mysql/$db/$table ; mysql $db -e 'flush tables;' ; unset db table
# db size monitor
cd /var/lib/mysql/ && ls -al
cd /var/lib/mysql/ && find ./ -size +100000k -exec ls -alh {} \; 
cd /var/lib/mysql/ && find ./ -size +20000k -exec ls -alh {} \; 
cd /var/lib/mysql/ && find ./ -size +20000k -mtime -1 -exec ls -alh {} \; 
# dump
mysqldump -Q varDBNAME > /root/varDBNAME.$(datetag1).sql ; ls -alh /root/varDBNAME.$(datetag1).sql
dbname=$( mysql -Be "show databases;"  | awk 'NR>1' | pipemenu1 ) ; mysqldump -Q $dbname > /root/$dbname.$(datetag1).sql ; ls -alh /root/$dbname.$(datetag1).sql
# dbs all dump
mkdir -p /varBackupDIR/ ; chmod 700 /varBackupDIR/ ; for i in $(mysql -Be "show databases;" | awk 'NR>1'); do echo "$i DB dumping..." ; mysqldump -Q $i | gzip > /varBackupDIR/${i}.$(datetag1).sql.gz; done ;  chmod 600 /varBackupDIR/*.sql.gz
# root
mysql -uroot -p mysql
mysql mysql
!!! mysql -e "grant all privileges on *.* to root@localhost identified by 'varPASSWORD';"
!!! mysql -e "drop database varDBNAME;"
# perm
chmod 660 /var/lib/mysql/mysql/*
chown mysql.mysql /var/lib/mysql/
chown mysql.root /var/lib/mysql/mysql
chmod 755 /var/lib/mysql
chmod 711 /var/lib/mysql/mysql
yyay mysql || yyay mariadb-server





%%% {submenu_hid}LVM - Logical Volume Manager [lvm]
# 물리 Disk 장착후 
fdisk -l 
# 파티션 생성후 type LVM 타입으로 변경 8e 
fdisk /dev/varDISK
# 물리볼륨생성 (ex. pvcreate /dev/sdb1 or pvcreate /dev/sdb)
fdisk -l /dev/varDISK ;; pvcreate /dev/varPartition
pvdisplay
pvs
# 볼륨그룹생성 /dev/vgname/ (ex. vgcreate vg-homegroup /dev/sdb1 /dev/sdc1 /dev/sdd1)
vgcreate varVGname varPartitions
# 볼륨그룹확장 (현재 볼륨그룹에 새로 추가한 pv ex. /dev/sdc1 추가) 
vgextend varVGname varNewPV
vgdisplay 
vgdisplay -v 
vgs
# 논리그룹 생성 /dev/vgname/lvname (ex. lvcreate -n lv-homefree -L 10000G vg-homegroup)
lvcreate -n varLVname -L varSIZE varVGname
lvdisplay
lvs
# 포맷 // mount // fstab
ls -1 /usr/sbin/mkfs*
mkfs.ext4 /dev/varVGname/varLVname 
mkfs.ext3 /dev/varVGname/varLVname 
mkfs.btrfs /dev/varVGname/varLVname 
mkfs.xfs /dev/varVGname/varLVname 
echo "#/dev/varVGname/varLVname varMountDIR ext4 defaults 1 2" >> /etc/fstab 
vi2 /dev/fstab
# lvextend -L [+|-]새로운 크기 [M|G|T] /dev/volume_group_name/logical_volume_name
!!! s=varSIZE ; lvextend -L+${s}G varLVpath
!!! lvextend -l +100%FREE varLVpath
resize2fs varLVpath
#
df -h


%%% {submenu_com}at / cron [at]
# at 확인 -> atqq func 
declare -f atqq
atqq | stripe
# at 삭제
atqq|stripe ;; atrm $( atq |while read -r l;do echo $l|awk1; done | pipemenu )
# at 모두 삭제
atqq|stripe ;; atrm $( atq |while read -r l;do echo -n $l|awk1; done )
# at 설정 
# echo "varCOMMAND" | at 15:30
echo "varCOMMAND" | at varTIME
# echo "varCOMMAND" | at 15:00 this Sat
# echo "varCOMMAND" | at 10:00 next week + Fri
# echo "varCOMMAND" | at 16:15 2025-08-03
echo "varCOMMAND" | at varTIME varDATE
# echo "varCOMMAND" | at now + 2h 30m
# echo "varCOMMAND" | at now + 3d 14:05
# echo "varCOMMAND" | at now + 2w 16:00
echo "varCOMMAND" | at now + varDATETIME 
# 이달말 
echo "varCOMMAND" | at varTIME $(date -d "$(date '+%Y-%m-01') 1 month -1 day" '+%Y-%m-%d')
#
# cron -> [0-9] * / - , 를 이용하여 표현, %는 줄바꿈 특수키
# min(0-59) hour(0-23) day(1-31) month(1-12) weekand(0-7) user command
# */5 * * * * root /script/per5min.sh 5분마다 실행
# 0 0 * * 0 root /script/sunday0hour.sh 일요일 자정에 실행
#
# 30 20-22/2 * * * root /script/am10pm10.sh 10~22시까지 2시간 마다 실행
echo $(date -d "$(date +'%Y-%m-01') 1 month -1 day" '+%m-%d')
echo $(date -d "$(date +'%Y-%m-01') 1 month -2 day" '+%m-%d')
echo $(date -d "$(date +'%Y-%m-01') 2 month -1 day" '+%m-%d')
# 이달의 마지막날 10시 실행되는 스크립트 
# 0 10 27-31 * * root [ "$(date '+\%d' -d tomorrow)" == 01 ] && /script/specialday.sh 말일에 실행
echo "varMin varHour varDay varMonth varWeekand varUser__root varComPath" >> /etc/crontab ; vi2 /etc/crontab
# /root /etc 폴더 증분백업 (최저부하) / 백업본 (7*24)
echo "varMin varHour varDay varMonth varWeekand varUser__root MY_DATE=\$(date +\%w\%H) && nice -n 19 ionice -c2 -n7 rsync -ar --backup --suffix=\".bak_\$MY_DATE\" varSource__@@root varSource2__@@etc varBackupDIR__@@backup@@" >> /etc/crontab ; vi2 /etc/crontab
vi2 /etc/crontab
cal || yyay ncal



%%% {submenu_com}find query [find]
# 폴더에서 검색문자열 탐색
for i in $( grep "varFIND" varPATH__@@etc/* -rlF 2>/dev/null ) ; do echo -n "$i " ;dline 40 ; grep "varFIND" $i ; echo ; done | cgrep varFIND |less -R
# 이진 파일을 제외하고 탐색 
find varPATH__@@etc -type f ! -iregex '.*\.\(jpg\|png\|gif\|pdf\|bin\|zip\|gz\|bz2\|tgz\|zst\|exe\|mp3\|mp4|sql\)$' | while read -r i; do if file -b "$i" | grep -q 'text' && grep -q "varFIND" "$i"; then echo -n "$i "; dline 40; grep "varFIND" "$i"; echo; fi; done | cgrep varFIND | less -R
#
vi2 varFILEPATH
# perm 000 폴더 find 
find varPATH/ -maxdepth 1 -type d -perm 000
# 하루내 수정된 파일을 찾기 /home 폴더안에 계정별 작업이 필요할때 
for i in $( cd varPATH__@@home1; ls -al |grep ^d |awk '{print $NF}' ); do find varPATH/$i -mtime -1 -type f; done 
# 특정단어포함 파일 삭제 *thumb*
!!! find varPATH -type f -name "*varFIND__thumb*" -maxdepth 1 -size 0 -exec rm -f {} \;
# expired account Lock // 특정폴더로 이동된 계정폴더를 기준 
!!! for i in $(/bin/ls -l varPATH__@@home1@@expire |awk '{print $NF}'); do passwd -l ${i%/} ; done
# 삭제된 계정 정리 // deleted account homedir cleaning
!!! cd varPATH && rm -rf `ls -al|awk '$3 ~ /^[0-9]/ {print $NF} '`
# 빈파일 빈폴더 탐색
find varPATH__@@home -type f -empty 
# 빈파일 삭제 
find varPATH__@@home -type f -empty -delete
find varPATH__@@home -type d -empty


%%% {submenu_com}vim 설정 / vi alias [vi]
# .vimrc scp
scp varHOST:~/.vimrc ~/.vimrc
#
# vim 에서 folding 제거 zo zf 
rbackup /root/.vimrc ; perl -pi -e 's|^set foldmethod=marker|" set foldmethod=marker|g' /root/.vimrc
# 비주얼 모드 off (mouse off)
rbackup /root/.vimrc ; echo "set mouse-=a" >> /root/.vimrc ; 
# 알록달록이
[ ! "$(grep "syntax" /root/.vimrc)" ] && echo -e "syntax on\ncolorscheme default\n" >> /root/.vimrc ; 
# backup file 
echo -e "set backup\nset backupdir=~/.vim/backup\n" >> /root/.vimrc
# 한글 encoding
echo "set fileencodings=utf8,euc-kr" >> /root/.vimrc
# 마우스 붙여 넣기 들여쓰기 방지 && f2 토글 
echo "set paste" >> /root/.vimrc
echo "set pastetoggle=<F2>" >> /root/.vimrc
# vim 종료시 vi 편집 내용 화면 그대로 남게 하기 
echo "set t_ti= t_te=" >> /root/.vimrc
# vi vim alias 
[ ! "$(grep " vi=" /root/.bashrc)" ] && echo "alias vi='vim'" >> /root/.bashrc
#
# tip ---
# vi 빈칸여러개->한칸: :'<,'>s/\s\+/ /g
#
vi2 /root/.vimrc
vi2 /etc/vimrc





%%% {submenu_hidden}rc.local service add [rc]
# 등록 서비스 체크
find /etc/systemd/system/ -name rc-local.service -exec echo {} \; -exec sh -c 'read x' \; -exec vi {} \;
systemctl list-unit-files --type=service | grep rc-local
# 서비스 등록
vi2 /etc/rc.local ; chmod +x /etc/rc.local ; 
vi2 /etc/systemd/system/rc-local.service
# 
[ ! -f /etc/systemd/system/rc-local.service ] && touch /etc/systemd/system/rc-local.service
echo -e "[Unit]\nDescription=/etc/rc.local Compatibility\nDocumentation=man:systemd-rc-local-generator(8)\nConditionFileIsExecutable=/etc/rc.local\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=5min\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target" | tee /etc/systemd/system/rc-local.service ; vi2 /etc/systemd/system/rc-local.service
#
systemctl enable rc-local.service
explorer /etc/systemd/system
#




%%% ssh connect / id_rsa [s]
ssh varHOST -p varPORT__22
ssh varHOST -p varPORT__22 "varCOMMAND" 
declare -f assh
# ssh // sshd 환경파일 수정 
vi2 $(ls -1 /root/.ssh/config /etc/openssh/sshd_config /etc/ssh/sshd_config 2>/dev/null |pipemenu1)
# 원격지 파일/폴더 select no. scp download
scp -r -P varPORT__22 varHOST:varRPATH__@@root/$(ssh varHOST -p varPORT__22 "ls -1 varRPATH__@@root"|pipemenu) varLocalPATH__.
# 개인키 / 공개키 
rbackup /root/.ssh/id_rsa /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys 
!!! scp varHOST:/root/.ssh/id_rsa.pub /root/.ssh/ 
!!! scp varHOST:/root/.ssh/id_rsa /root/.ssh/ 
!!! ssh-keygen -t rsa -b 2048 -f /root/.ssh/id_rsa
# 로컬 공개키 대상 서버에 복사 // 로컬에서 원격지로 키로그인
!!! ssh-copy-id varHOST
!!! ssh-copy-id -p varPORT__22 -i $( find /root/.ssh -name "*.pub"|pipemenu1) varHOST
!!! cat /root/.ssh/id_rsa.pub | ssh varHOST "cat >> /root/.ssh/authorized_keys"
# 원격지 공개키 현재 서버에 복사 // 원격지에서 로컬로 키로그인
!!! ssh varHOST "cat .ssh/id_rsa.pub" | tee -a /root/.ssh/authorized_keys
# 원격지 공개키 저장소 로컬 동기화 // 원격지 키로그인 가능한 게스트는 이서버도 가능
!!! scp varHOST:/root/.ssh/authorized_keys /root/.ssh/ 
#
# kex server side
ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 varHOST
echo -e "KexAlgorithms +diffie-hellman-group1-sha1 \nHostKeyAlgorithms +ssh-rsa,ssh-dss \nPubkeyAcceptedKeyTypes=+ssh-rsa \nPubkeyAcceptedAlgorithms=+ssh-rsa" >> /etc/ssh/sshd_config ; vi2 /etc/ssh/sshd_config
#
ssh -v varHOST -p varPORT__22
sshd -T |grep rsa 
systemctl restart sshd
# client ssh handshake 
echo -e "Host varHOST\nKexAlgorithms +diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1\nHostKeyAlgorithms +ssh-rsa,ssh-dss\nPubkeyAcceptedKeyTypes ssh-rsa,ssh-ed25519\nRequiredRSASize 1024" >> /root/.ssh/config ; vi2 /root/.ssh/config





%%% screen [x] / tmux (xx)
%% screen -ls|grep tach
screen -ls
screen -ls ;; screen -S varA
# multi mode / all -x / -rd (detach & retach)
screen -ls ;; screen -x $( screen -ls |grep tach |pipemenu1 )
screen -ls ;;  for i in $( screen -ls |grep tach |awk1 ) ;do echo $i ; sleep 1 ; screen -x $i ; done
screen -ls ;; screen -rd varA
# 프로그램이나 스크립트 screen 으로 실행 
screen -dmS $(basename varCommandPATH) sh -c 'varCommandPATH' 
screen -S $(basename varCommandPATH) sh -c 'varCommandPATH;/bin/bash' 
# screen dump
screen -ls ;; screen -S $( screen -ls |grep tach |pipemenu1 ) -X hardcopy -h /root/_screendump && cat /root/_screendump |cpipe|less -R +G && rm -f /root/_screendump
# screen dump all
for i in $( screen -ls|grep tach|awk '{print $1}' ) ;do echo "$i ===========================" && screen -S $i -X hardcopy -h /root/_screendump && tail -n100 /root/_screendump | cpipe && echo -n "=== end of $i [Enter] " && read x ; done ; rm -rf /root/_screendump 
# screen quit
!!! screen -ls ;; screen -S $( screen -ls |grep tach |pipemenu1cancel ) -X quit ; screen -ls 
# monitor 
c=('top' 'iftop' 'sh -c "pstree; exec bash"'); s(){ screen "$@"; }; s -dmS m ${c[0]}; for x in "${c[@]:1}"; do s -S m -X screen; s -S m -X stuff "${x}\n"; done; s -r m
# command to screen // & dump 
screen -ls ;; screen -S varA -X stuff "varCommand$(printf \\\\r)"
screen -ls ;; sno=$( screen -ls |grep tach |pipemenu1 ) ;; screen -S $sno -X stuff "varCommand$(printf \\\\r)" ;; screen -S $sno -X hardcopy -h /root/_screendump && cat /root/_screendump |cpipe && rm -f /root/_screendump
# detach 제거
!!! for i in $( screen -ls|grep detach|awk '{print $1}' ) ;do screen -S $i -p 0 -X quit; done ; screen -ls
# attach / detach 모두 제거
!!! for i in $( screen -ls|grep tach|awk '{print $1}' ) ;do screen -S $i -p 0 -X quit; done ; screen -ls
# 검색 문자열 screen 제거
!!! screen -ls ;; for i in $( screen -ls|grep tach|grep varA|awk '{print $1}' ) ;do screen -S $i -p 0 -X quit; done ;screen -ls


%%% {submenu_hidden}rclone [cc]
%% df | grep /mnt | cdir
curl https://rclone.org/install.sh | bash ;; rclone --version
rclone config
# cloud token config 가 Rhost 에 있다면 copy
mkdir -p /root/.config/rclone/ ; scp varHOST:/root/.config/rclone/rclone.conf /root/.config/rclone/ ; vi2 /root/.config/rclone/rclone.conf
mkdir -p /tmp/rclone/Cache /tmp/rclone/Log ; chmod 700 /tmp/rclone ; ls -al /tmp/rclone
vi2 /root/.config/rclone/rclone.conf
# var export 
echo "CLOUD='varCLOUD__gdrive' ; RMOUNT='varRdir__rclone_share' ; LMOUNT='varLdir__gdrive_mount' ; LTMP='/tmp/rclone'" > /tmp/rclone/var.conf
echo "CLOUD='varCLOUD__gcp' ; RMOUNT='varRdir__rclone_share' ; LMOUNT='varLdir__gcp_mount' ; LTMP='/tmp/rclone'" > /tmp/rclone/var.conf
echo "CLOUD='varCLOUD__onedrive' ; RMOUNT='varRdir__rclone_share' ; LMOUNT='varLdir__onedrive_mount' ; LTMP='/tmp/rclone'" > /tmp/rclone/var.conf
cat /tmp/rclone/var.conf
# after var export // import env && rclone { mkdir,copy,ls } test
# 아래 명령시 에러가 나지 않을경우 마운트가 가능
. /tmp/rclone/var.conf ; mkdir -p /mnt/$LMOUNT ; rclone mkdir $CLOUD:$RMOUNT 
. /tmp/rclone/var.conf ; mkdir -p /mnt/$LMOUNT ; rclone copy /root/.config/rclone/rclone.conf $CLOUD:$RMOUNT 
. /tmp/rclone/var.conf ; mkdir -p /mnt/$LMOUNT ; rclone lsd $CLOUD: ; rclone ls $CLOUD:$RMOUNT
# rclone mount
. /tmp/rclone/var.conf ; rclone mount $CLOUD:$RMOUNT /mnt/$LMOUNT --config /root/.config/rclone/rclone.conf --daemon --allow-other --allow-non-empty --fast-list --drive-skip-gdocs --poll-interval=15s --vfs-cache-mode full --vfs-write-back 5s --bwlimit-file 16M --buffer-size=16M --vfs-read-chunk-size=32M --vfs-read-chunk-size-limit 2048M --vfs-cache-max-size 10G --vfs-cache-max-age 336h --vfs-read-ahead 32M --dir-cache-time=1000h --log-level INFO --log-file $LTMP/Log/rclone.log --cache-dir=$LTMP/Cache --timeout 1h --umask 000 ; df | grep /mnt | cdir
# 서브쉘에서 마운트 할 경우, 서브쉘 종료시 마운트가 해제되는것 방지 
. /tmp/rclone/var.conf ; cd /mnt/$LMOUNT && ( echo $(date "+%Y%m%d_%H%M%S") > /mnt/$LMOUNT/rclone_mounted.txt ) && explorer /mnt/$LMOUNT || { cd /mnt && ls -al ; }
# rc.local 에 추가
cat /tmp/rclone/var.conf >> /etc/rc.local ; echo -e "mkdir -p /tmp/rclone/Cache /tmp/rclone/Log ; chmod 700 /tmp/rclone\nmkdir -p /mnt/$LMOUNT ; rclone mkdir $CLOUD:$RMOUNT\nrclone mount $CLOUD:$RMOUNT /mnt/$LMOUNT --config /root/.config/rclone/rclone.conf --daemon --allow-other --allow-non-empty --fast-list --drive-skip-gdocs --poll-interval=15s --vfs-cache-mode full --vfs-write-back 5s --bwlimit-file 16M --buffer-size=16M --vfs-read-chunk-size=32M --vfs-read-chunk-size-limit 2048M --vfs-cache-max-size 10G --vfs-cache-max-age 336h --vfs-read-ahead 32M --dir-cache-time=1000h --log-level INFO --log-file $LTMP/Log/rclone.log --cache-dir=$LTMP/Cache --timeout 1h --umask 000 " >> /etc/rc.local
#
# unmount // explorer // update
df ;; . /tmp/rclone/var.conf ; umount /mnt/$LMOUNT
explorer /mnt/$LMOUNT
rclone selfupdate --stable




%%% {submenu_hidden}tmux [xx]
# prefix key ctrl-b ( screen -> ctrl-a )
tmux 
tmux ls
tmux attach 
tmux attach -t $( tmux ls|awk -F: '{print $1}' | pipemenu ) 
tmux kill-session 
tmux kill-session -t $( tmux ls|awk -F: '{print $1}' | pipemenu ) 
tmux kill-server
tmux new-session -d 'bashtop' \; new-window 'top' \; new-window 'iftop' \; new-window 'sh -c "pstree; exec bash"'; tmux attach
# 새로운 윈도우 생성: Ctrl-b c (create)
# 다음 윈도우로 이동: Ctrl-b n (next)
# 이전 윈도우로 이동: Ctrl-b p (prev)
# 세로 분할: Ctrl-b %
# 가로 분할: Ctrl-b "
# 패널 이동: Ctrl-b 방향키
# 패널 크기 조절: Ctrl-b Ctrl-방향키
# 스크롤 모드: Ctrl-b [
# 스크롤 모드 종료: q
# 탈출 (detach)하여 현재 세션 종료: Ctrl-b d
#
# install
yyay tmux





%%% {submenu_docker}proxmox [px]
%% vmslistview|cgrep3136 running
pct list
qm list
# lxc 
pct list ;; pct $(echo enter start stop reboot config |pipemenu) varPCTID
# qemu
qm list ;; qm $( echo start stop reset config |pipemenu) varVMID
# qemu enter (ssh)
vmslist | grep qemu | cgrep running ;; qmip=$( qm agent varVMID network-get-interfaces | gipa | grep -v "127.0.0.1" ); [ "$qmip" ] && ssh root@$qmip
# shell
pvesh get cluster/resources
pvesh get $( echo cluster/status /nodes /storage | pipemenu )
# cluster
pvecm $( echo status nodes | pipemenu ) 
pvecm expected 1 
# cluster node del
rbackup varBackupDIR__@@backup/etc_daily.tgz ; tar cvzf varBackupDIR__@@backup/etc_daily.tgz /etc/ 
pvecm delnode varNodename
ls -al /etc/pve/nodes ;; rm -r /etc/pve/nodes/varNodename
systemctl restart pve-cluster
# storage
pvesm status
pvesm list $( pvesm status |awk1 |awknr2 |pipemenu ) 
pvesm scan ;; pvesm scan varA
# mount/unmount - vm pct
pvesm status ; lvs ;; qm set varVMID $( echo -scsi0 -scsi1 -scsi2 -ide0 -ide1 -ide2 |pipemenu) varSTGName:varLVName
pvesm status ; lvs ;; qm set varVMID $( echo -scsi0 -scsi1 -scsi2 -ide0 -ide1 -ide2 |pipemenu) none
pvesm status ; lvs ;; pct set varVMID $( echo -mp0 -mp1 -mp2 |pipemenu) varSTGName:varLVName,mp=/mnt/disk1
pvesm status ; lvs ;; pct set varVMID $( echo -mp0 -mp1 -mp2 |pipemenu) none
# qm importdisk <vmid> /var/lib/vz/images/your-image.qcow2 local-lvm
pvesm status ; lvs ;; qm importdisk varVMID varQCowPATH varSTGName
#
pvesh get /storage -output-format=yaml |cgrep backup |cgrep1 storage 
pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'
# pveam lxc download 
pveam update ; pveam available ; pvesm status ;; pveam download varSTRG__local $( pveam available|awk2 |pipemenu1  ) 
# vm/pct dump / dump all
vzdump varVMID --mode snapshot --storage varSTG --node varNODE --compress zstd --notes-template '{{guestname}}' --remove 0
vzdump --all   --mode snapshot --storage varSTG --node varNODE --compress zstd --remove 0
# user add / passwd
pveum useradd varUser ;; pveum passwd varUser
explorer /etc/pve/local/


%%% {submenu_docker}proxmox helper script [pxh]
%% vmslistview|cgrep3136 running
# https://tteck.github.io/Proxmox/
# post
# Removes subscription dialogs, replaces enterprise repository with non-subscription repository - 7.xx
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/misc/post-pve-install.sh)"
# backup-server Removes sub..
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/misc/post-pbs-install.sh)"
# Monitor All (all VMs start)
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/misc/monitor-all.sh)"
# apps
# Nginx Proxy Manager LXC IP:81 username admin@example.com password changeme
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/nginxproxymanager.sh)"
# WireGuard LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/wireguard.sh)"
# Home Assistant OS VM IP:8123
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/vm/haos-vm.sh)"
# Docker LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/docker.sh)"
# Transmission LXC (BitTorrent client) user/password transmission IP:9091/transmission
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/transmission.sh)"
# TurnKey File Server LXC (SMB, SFTP, NFS, WebDAV and rsync)
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-fileserver.sh)"
# TurnKey Nextcloud LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-nextcloud.sh)"
# TurnKey OpenVPN LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-openvpn.sh)"
# TurnKey Torrent Server LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-torrentserver.sh)"
# TurnKey Wordpress LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-wordpress.sh)"
# 
# install
yyay qemu-guest-agent ; systemctl start qemu-guest-agent || /etc/init.d/qemu-ga start
yyay bsdextrautils





%%% {submenu_docker}kvm hypervisor [kvm]
# kvm support cpu  check
egrep -c '(vmx|svm)' /proc/cpuinfo
yy qemu qemu-kvm qemu-img libvirt libvirt-python libvirt-client virt-install bridge-utils gemu-guest-agent libguestfs-tools 
yum groupinstall -y virtualization-client virtualization-platform virtualization-tools
# gui
yy virt-manager xorg-x11-xauth xorg-x11-fonts-* xorg-x11-utils
virtmanager
# daemon
Systmectl enable libvirtd ; Systemctl start libvirtd ; Systemctl status libvirtd
lsmod | grep -i kvm
# virt-install centos7
sudo virt-install --name centos7 --ram 2048 --disk path=/var/lib/libvirt/images/centos7.img,size=20 --vcpus 2 --os-type linux --os-variant centos7.0 --network bridge=virbr0 --graphics none --console pty,target_type=serial --location 'http://mirror.kakao.com/centos/7/os/x86_64/' --extra-args 'console=ttyS0,115200n8 serial' 
# list
virsh list --all
virsh start varVM
virsh shutdown varVM
!!! virsh undefine varVM
# resize
cd /var/lib/libvirt/images ; ls -al
qemu-img resize varIMG.qcow2 + "varSIZE"G
# net
cd /etc/sysconfig/network-scripts/ ; ls -al
cd /etc/sysconfig/network-scripts/ ; ls -al ;; cp ifcfg-varENS ifcfg-br0 ; echo "BRIDGE=br0" >> ifcfg-varENS ; echo "TYPE=Bridge" >> ifcfg-br0 ; vi2 ifcfg-br0 ; 
systemctl restart network
ip addr show br0
# swap off
!!! swapoff -a && sed -i '/swap/s/^/#/' /etc/fstab
# qemu-img convert
# dd dump varDevice(ex. /dev/sda) -> varDevice.raw
dd if=varDevice of=/backup/$(basename varDevice).raw
# dd dump -> qcow2
dd if=varDevice | qemu-img convert -p -f raw -O qcow2 /dev/stdin /backup/$(basename varDevice).qcow2
# raw device -> qcow2 device ex.) /dev/vg-950/vm-101-disk-1 
qemu-img convert -p -f raw -O qcow2 varDevice /backup/$(basename varDevice).qcow2
# raw img(dd,raw,img) -> qcow2
qemu-img convert -p -f raw -O qcow2 /backup/varIMG /backup/varIMG.qcow2
# raw img(dd,raw,img) -> vmdk 
qemu-img convert -p -f raw -O vmdk /backup/varIMG /backup/varIMG.vmdk
# vmdk -> qcow2
qemu-img convert -pO qcow2 -f vmdk /backup/varVMDK /backup/varVMDK.qcow2







%%% {submenu_docker}minecraft [mc]
screen -ls 
# screen retach
screen -ls ;; screen -x $( screen -ls |grep tach |pipemenu1 )
# start // restart
echo "eula=true" > /root/Minecraft/eula.txt ; screen -dmS varNAME__mc /root/Minecraft/run.sh nogui ; screen -x varNAME__mc 
screen -ls ;; screen -S varNAME__mc -X quit ; screen -ls ; screen -dmS varNAME__mc /root/Minecraft/run.sh nogui && screen -x varNAME__mc
# stop // stop force // java running kill
screen -ls ;; screen -S varNAME__mc -X quit ; screen -ls
ps -ef|grep "$(basename $(readlink /root/Minecraft))"|awk '{print $2}'|xargs kill -
ps -ef|grep [j]ava|awk '{print $2}'|xargs kill 2>/dev/null ; sleep 2 ; screen -ls
# bungeecord start // restart // stop
screen -dmS bungeecord /root/bungeecord/run.sh nogui && screen -x bungeecord
screen -S bungeecord -X quit && screen -dmS bungeecord /root/bungeecord/run.sh nogui && screen -x bungeecord
screen -S bungeecord -X quit 
#
# port chg (default:25565)
sed -i -E "s/(^server-port=).*/\1varPORT__25565/g" /root/Minecraft/server.properties ; cat /root/Minecraft/server.properties|grep server-port
explorer /root/$(ls -1 /root|grep Minecraft|pipemenu1 )
# 
# screen dump view
screen -S $( screen -ls |grep tach |pipemenu1 ) -X hardcopy -h /root/_screendump ; cat /root/_screendump | cip |less -R +G ; rm -f /root/_screendump





%%% {submenu_docker}minecraft install [mci]
# paper server install
dir="/root/Minecraft.paper" ; link="https://api.papermc.io/v2/projects/paper/versions/1.20.1/builds/43/downloads/paper-1.20.1-43.jar" ; file=${link##*/} ; [ ! -d $dir ] && mkdir $dir ; cd $dir ; [ -L "/root/Minecraft" ] && rm /root/Minecraft ; ln -s $dir /root/Minecraft ; [ ! -f $file ] && wget $link ; echo "java -Xms1G -Xmx10G -Djava.awt.headless=true -jar $dir/$file" > $dir/run.sh ; chmod 700 run.sh 
# 
# forge server install
dir="/root/Minecraft.forge" ; link="https://maven.minecraftforge.net/net/minecraftforge/forge/1.19.2-43.2.3/forge-1.19.2-43.2.3-installer.jar" ; file=${link##*/} ; [ ! -d $dir ] && mkdir $dir ; cd $dir ; [ -L "/root/Minecraft" ] && rm /root/Minecraft ; ln -s $dir /root/Minecraft ; [ ! -f $file ] && wget $link ; java -jar $file  -installServer ; echo "-Xms1G -Xmx10G" > user_jvm_args.txt
# 
# bungeecord https://www.spigotmc.org/wiki/bungeecord-installation/
dir="/root/Minecraft.bungeecord" ; link="https://ci.md-5.net/job/BungeeCord/lastSuccessfulBuild/artifact/bootstrap/target/BungeeCord.jar" ; file=${link##*/} ; [ ! -d $dir ] && mkdir $dir ; cd $dir ; [ ! -L "/root/bungeecord" ] && ln -s $dir /root/bungeecord ; [ ! -f $file ] && wget $link ; echo "java -Xms1G -Xmx1G -Djava.awt.headless=true -jar $dir/$file" > $dir/run.sh ; chmod 700 run.sh
# 
vi2 $(echo "/root/Minecraft.bungeecord/config.yml /root/Minecraft/server.properties"|pipemenu )
# java & etc install
aptupup ; yyay openjdk-17-jdk wget screen




%%% find nfs at,cron vi ansible git irc [com]
{submenu_com}


%%% docker / kvm / proxmox / minecraft [v]
{submenu_docker}
%% dockersvcorg | column -t 
%% able docker && dockerps=$(docker ps|awknr2 2>/dev/null) && [ "${dockerps}" ] && echo && echo "$dockerps"| maxl 20 20 0 0 0 0 0 0 0 15 15 15 0 0 0 0 0|stripe |column -t




%%% {submenu_sys}nagios cli monitoring [na]
# HOST 의 web/ pop/ imap/ ftp/ ssh/ smtp/ mysql 데몬 구동 체크 
# yum
yy epel-release
yy nagios nagios-plugins-all
rpm -qa | grep nagios
for i in $( rpm -qa|grep nagios ) ; do rpm -ql $i ; done | grep "check_"
# apt
ay nagios4 monitoring-plugins-basic monitoring-plugins-standard
# 주요 서비스 체크 softlink
cd /usr/lib64/nagios/plugins/ || cd /usr/lib/nagios/plugins/ ; ls -al 
mkdir -p /root/checkup && for script in check_http check_pop check_imap check_ftp check_ssh check_smtp check_mysql; do ln -s $(pwd)/$script /root/checkup/; done ; ls -al /root/checkup
ls -al /root/checkup
host=varHOST__localhost; for i in $( find /root/checkup/ -type l ) ; do $i $host ; done | cgrep 거부 port Can\'t | cgrep1 OK
# 
systemctl stop omd.service
systemctl disable omd.service





%%% {submenu_docker}docker install / reset [dki]
%% dockersvc
# 
yyay apt-transport-https ca-certificates curl gnupg lsb-release
# gpg key add
: debian_gpg ;curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
: ubuntu_gpg ;curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
# repo add
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list ; vi2 /etc/apt/sources.list.d/docker.list
# 
# docker install
aptupup ; yyay docker.io  
# group user add
cat /etc/group|grep  "," ;; usermod -aG varGroup__docker varUSER ; vi2 /etc/group
# 
# docker compose install
curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose && chmod +x /usr/local/bin/docker-compose && ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
docker-compose --version
systemctl status docker ; docker --version
#
# docker all stop 
docker stop $( docker ps -a --filter "status=running" |awk1|awknr2 ) ; docker ps -a 
# docker reset
docker volume ls | awknr2 | awk2
docker images | awknr2 | awk1 
# prune
!!! docker container prune
!!! docker image prune -a
!!! docker network prune
!!! docker volume prune
# unused all prune
!!! docker system prune -a 




%%% {submenu_docker}docker ps [dk]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# docker ps // start // stop 
docker ps 
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker restart $( docker ps -a --filter "status=running" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
# rm
!!! docker ps -a ;; docker rm $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
# image
docker images
!!! docker image rm $( docker images | awk 'NR>1 {print $1}' | pipemenu1cancel ) ; echo ; docker images
# pull
docker pull varCTName__nginx
# volume
docker volume create varDATA__portainer_data
docker volume inspect $( docker volume ls | awknr2|awk2|pipemenu) 
!!! docker volume rm  $( docker volume ls | awknr2|awk2|pipemenu) 
cd /var/lib/docker/volumes ; explorer /var/lib/docker/volumes
# exec -it (interative tty container) 
docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) bash
# inspect
docker ps -a ;; docker inspect $( docker ps -a --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
# top // logs
docker ps ;; docker top $( docker ps --format "{{.Names}}"|pipemenu1 )
docker ps ;; docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1 )
# network 
docker network ls
docker network ls ;; docker network inspect $( docker network ls | awk 'NR>1 {print $1}' | pipemenu1 ) |cip
#




%%% {submenu_docker}docker run [dkr]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
#
# portainer 
docker run -d --name portainer --restart on-failure -p varWPORT__9000:9000 -p varBPORT__8000:8000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest
# nginx
docker run -d --name nginx -p varPORT__8080:80 nginx
mkdir -p /opt/docker ; docker run -d --name nginx -p varPORT__80:80 -v /opt/docker:/usr/share/nginx/html nginx
# mysql 
docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=varRootPW__wppass -e MYSQL_DATABASE=wp -e MYSQL_USER=wp -e MYSQL_PASSWORD=varPASS__wppass -v mysql_data:/var/lib/mysql mysql
# wordpress
docker run -d --name wp -p varPORT__8888:80 --link mysql:wp -e WORDPRESS_DB_HOST=wp -e WORDPRESS_DB_USER=wp -e WORDPRESS_DB_PASSWORD=varPASS__wppass -e WORDPRESS_DB_NAME=wp -v wordpress_data:/var/www/html wordpress
# minecraft
docker run -d --name mcserver --rm -e MEMORYSIZE='varMEM__1G' -v mc_data:/data:rw -p varPORT__25565:25565 -i marctv/minecraft-papermc-server:latest
# phpmyadmin ( depend on running db ) 
docker run --name mypma --rm -d --link $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ):db -p varPORT__3307:80 phpmyadmin/phpmyadmin
# phpmyadmin ( all host ) 
docker run --name mypmaall --rm -d -e PMA_ARBITRARY=1 -p varPORT__3300:80 phpmyadmin
# derkades/webdav
mkdir -p varMountPath__@@data@@webdav ; docker run -d --name webdav-instance --restart=unless-stopped -v varMountPath__@@data@@webdav:/data -p varPORT__8010:80 -e USERNAME=varUSER__admin -e PASSWORD=varPASS__gosh derkades/webdav
# ugeek/webdav
mkdir -p varMountPath__@@data@@webdav ; docker run -d  --name webdav --restart=unless-stopped -p varPORT__8010:80 -v varMountPath__@@data@@webdav:/media -e USERNAME=varUSER__admin -e PASSWORD=varPASS__gosh -e TZ=Asia/Seoul -e UID=1001 -e GID=1001  -d  ugeek/webdav:amd64
# wetty web-ssh 
docker run --name Wetty -d --rm -p 3000:3000 wettyoss/wetty --ssh-host $publicip --ssh-port 22 --base
#
# docker ps // start // stop // rm
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
!!! docker ps -a ;; docker rm $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps



%%% {submenu_docker}docker linux [dkl]
%% dockersvc
# linux docker image
docker run -it ubuntu bash
docker run -it centos bash
docker run -it debian bash
docker run -it fedora bash
# node.js ...
docker run -it node bash
docker run -it python bash
docker run -it mysql bash
docker run -it redis bash
docker run -it nginx bash




#%%% {submenu_docker}docker compose cacti [dkct]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@cacti"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/cacti}/{cacti_data,cacti_config}
cd ${varl1:-/data/cacti} ; ls -al ${varl1:-/data/cacti} 
cat ${varl1:-/data/cacti}/docker-compose.yml
#
!!! template_copy cacti.yml ${varl1:-/data/cacti}/docker-compose.yml ; cat ${varl1:-/data/cacti}/docker-compose.yml
vi2 ${varl1:-/data/cacti}/docker-compose.yml
# admin / admin
cd ${varl1:-/data/cacti}; docker-compose ps
cd ${varl1:-/data/cacti}; docker-compose up -d --remove-orphans
cd ${varl1:-/data/cacti}; ( trap 'return' SIGINT ; docker-compose logs -f )
cd ${varl1:-/data/cacti}; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/cacti}; docker-compose down
!!! cd ${varl1:-/data/cacti}; docker-compose down -v
#
cd ${varl1:-/data/cacti}; docker-compose exec mongo mongosh --eval "rs.initiate()"
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 




%%% {submenu_docker}docker compose ansible webui semaphore [dkse]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@semaphore"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/semaphore}/
cd ${varl1:-/data/semaphore} ; ls -al ${varl1:-/data/semaphore} 
cat ${varl1:-/data/semaphore}/docker-compose.yml
#
!!! template_copy semaphore.yml ${varl1:-/data/semaphore}/docker-compose.yml ; cat ${varl1:-/data/semaphore}/docker-compose.yml
vi2 ${varl1:-/data/semaphore}/docker-compose.yml
# IP:3000 admin / changeme
cd ${varl1:-/data/semaphore}; docker-compose ps
cd ${varl1:-/data/semaphore}; docker-compose up -d --remove-orphans
cd ${varl1:-/data/semaphore}; ( trap 'return' SIGINT ; docker-compose logs -f )
cd ${varl1:-/data/semaphore}; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/semaphore}; docker-compose down
!!! cd ${varl1:-/data/semaphore}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 




%%% {submenu_docker}docker compose nagios [dkna]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@nagios"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/nagios}/{nagios/{etc,var},custom-plugins,nagiosgraph/{var,etc}}
cd ${varl1:-/data/nagios} ; ls -al ${varl1:-/data/nagios} 
cat ${varl1:-/data/nagios}/docker-compose.yml
#
!!! template_copy nagios.yml ${varl1:-/data/nagios}/docker-compose.yml ; cat ${varl1:-/data/nagios}/docker-compose.yml
vi2 ${varl1:-/data/nagios}/docker-compose.yml
# nagiosadmin / nagios
cd ${varl1:-/data/nagios}; docker-compose ps
cd ${varl1:-/data/nagios}; docker-compose up -d --remove-orphans
cd ${varl1:-/data/nagios}; ( trap 'return' SIGINT ; docker-compose logs -f )
cd ${varl1:-/data/nagios}; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/nagios}; docker-compose down
!!! cd ${varl1:-/data/nagios}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 




%%% {submenu_docker}docker compose Rocket.Chat [dkro]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@rocketchat"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/rocketchat}/{uploads,data/db,data/dump}
cd ${varl1:-/data/rocketchat} ; ls -al ${varl1:-/data/rocketchat} 
cat ${varl1:-/data/rocketchat}/docker-compose.yml
#
!!! template_copy rocketchat.yml ${varl1:-/data/rocketchat}/docker-compose.yml ; vi2 ${varl1:-/data/rocketchat}/docker-compose.yml
!!! curl -L https://go.rocket.chat/i/docker-compose.yml -o ${varl1:-/data/rocketchat}/docker-compose.yml
vi2 ${varl1:-/data/rocketchat}/docker-compose.yml
#
cd ${varl1:-/data/rocketchat}; docker-compose ps
cd ${varl1:-/data/rocketchat}; docker-compose up -d --remove-orphans
cd ${varl1:-/data/rocketchat}; ( trap 'return' SIGINT ; docker-compose logs -f )
cd ${varl1:-/data/rocketchat}; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/rocketchat}; docker-compose down
!!! cd ${varl1:-/data/rocketchat}; docker-compose down -v
#
cd ${varl1:-/data/rocketchat}; docker-compose exec mongo mongosh --eval "rs.initiate()"
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 



%%% {submenu_docker}docker compose wg-easy wireguard [dkw]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@wireguard"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/wireguard}/data
cd ${varl1:-/data/wireguard}/data ; ls -al ${varl1:-/data/wireguard} ${varl1:-/data/wireguard}/data
cat ${varl1:-/data/wireguard}/docker-compose.yml
#
!!! template_copy wireguard.yml ${varl1:-/data/wireguard}/docker-compose.yml ; vi2 ${varl1:-/data/wireguard}/docker-compose.yml
sed -i 's/ WG_HOST=.*/ WG_HOST='"$publicip"'/' ${varl1:-/data/wireguard}/docker-compose.yml
hostname ; readx ; sed -i 's/ WG_HOST=.*/ WG_HOST='"$(hostname)"'/' ${varl1:-/data/wireguard}/docker-compose.yml
sed -i 's/PASSWORD=.*$/PASSWORD='varPASSWORD'/' ${varl1:-/data/wireguard}/docker-compose.yml
sed -i 's|- /data/wireguard/data|- '"${varl1:-/data/wireguard}"'/data|g' ${varl1:-/data/wireguard}/docker-compose.yml
vi2 ${varl1:-/data/wireguard}/docker-compose.yml
#
cd ${varl1:-/data/wireguard}/data ; docker-compose ps
cd ${varl1:-/data/wireguard}/data ; docker-compose up -d
cd ${varl1:-/data/wireguard}; ( trap 'return' SIGINT ; docker-compose logs -f )
cd ${varl1:-/data/wireguard}/data ; docker-compose down
!!! cd ${varl1:-/data/wireguard}/data ; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 


%%% {submenu_docker}docker compose rhymix/nginx/mariadb [dkrm]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@rhymix"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/rhymix}
cd ${varl1:-/data/rhymix}; ls -al ${varl1:-/data/rhymix}
cd $( dirname ${varl1:-/data/rhymix} ) ; git clone https://github.com/devjiro76/rhymix_docker.git rhymix 
# 서비스 포트 수정 
vi2 ${varl1:-/data/rhymix}/docker-compose.yml
explorer ${varl1:-/data/rhymix}/
cd ${varl1:-/data/rhymix}; vi2 init.sh
# php7.1 -> 7.4up
!!! template_copy php74.docker.yml ${varl1:-/data/rhymix}/dockers/php-fpm/Dockerfile
cd ${varl1:-/data/rhymix}; sh init.sh
#
cd ${varl1:-/data/rhymix}; docker-compose ps
cd ${varl1:-/data/rhymix}; docker-compose up -d
cd ${varl1:-/data/rhymix}; ( trap 'return' SIGINT ; docker-compose logs -f )
cd ${varl1:-/data/rhymix}; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/rhymix}; docker-compose down
!!! cd ${varl1:-/data/rhymix}; docker-compose down -v
# err check : /usr/share/nginx/html/common/manual/server_config/rhymix-nginx.conf: location / 범위 주석
cd ${varl1:-/data/rhymix}; vi2 web/common/manual/server_config/rhymix-nginx.conf
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 



%%% {submenu_docker}docker compose wordpress / phpmyadmin [dkwp]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@wordpress"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/wordpress}/{db,data}
cd ${varl1:-/data/wordpress}; ls -al ${varl1:-/data/wordpress}
cat ${varl1:-/data/wordpress}/docker-compose.yml
#
# template -> wp:latest / mysql:latest / phpmyadmin
!!! template_copy wordpress.yml ${varl1:-/data/wordpress}/docker-compose.yml ; cat ${varl1:-/data/wordpress}/docker-compose.yml
sed -i 's|VOLUMEPATH|'"${varl1:-/data/wordpress}"'/data|g' ${varl1:-/data/wordpress}/docker-compose.yml
sed -i 's|- "8080:80"|- "varPORT:80"|g' ${varl1:-/data/wordpress}/docker-compose.yml
vi2 ${varl1:-/data/wordpress}/docker-compose.yml
#
cd ${varl1:-/data/wordpress}; docker-compose ps
cd ${varl1:-/data/wordpress}; docker-compose up -d
cd ${varl1:-/data/wordpress}; ( trap 'return' SIGINT ; docker-compose logs -f )
cd ${varl1:-/data/wordpress}; docker-compose down
!!! cd ${varl1:-/data/wordpress}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 




%%% {submenu_docker}docker compose traefik [dkt]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@traefik"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/traefik}/data
cd ${varl1:-/data/traefik}/data ; ls -al ${varl1:-/data/traefik} ${varl1:-/data/traefik}/data
cat ${varl1:-/data/traefik}/docker-compose.yml
#
# template -> 
!!! template_copy traefik.yml ${varl1:-/data/traefik}/docker-compose.yml ; cat ${varl1:-/data/traefik}/docker-compose.yml
vi2 ${varl1:-/data/traefik}/docker-compose.yml
#
cd ${varl1:-/data/traefik}/data ; docker-compose ps
cd ${varl1:-/data/traefik}/data ; docker-compose up -d
cd ${varl1:-/data/traefik}/data ; docker-compose restart $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel )
cd ${varl1:-/data/traefik}/data ; docker-compose down
!!! cd ${varl1:-/data/traefik}/data ; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps




%%% {submenu_docker}docker compose guacamole [dkg]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@guacamole"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/guacamole}/data
cd ${varl1:-/data/guacamole}/data ; ls -al ${varl1:-/data/guacamole} ${varl1:-/data/guacamole}/data
# git clone 
git clone "https://github.com/boschkundendienst/guacamole-docker-compose.git" 
cd guacamole-docker-compose && ./prepare.sh
cd ${varl1:-/data/guacamole}/data ; mv guacamole-docker-compose/* ..
cat ${varl1:-/data/guacamole}/docker-compose.yml
#
vi2 ${varl1:-/data/guacamole}/docker-compose.yml
#
# guacamole guacd nginx postgres 
# https://publicip:8443 (guacadmin/guacadmin)
#
cd ${varl1:-/data/guacamole}/data ; docker-compose ps
cd ${varl1:-/data/guacamole}/data ; docker-compose up -d
cd ${varl1:-/data/quacamole}/data ; docker-compose restart $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel )
cd ${varl1:-/data/guacamole}/data ; docker-compose down
!!! cd ${varl1:-/data/guacamole}/data ; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps



%%% {submenu_docker}docker compose home assistant os [dkha]
%% dockersvc
%% [ "$mydomain" ] && echo "MyDomain: $mydomain"
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@haos"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/haos}/config
cd ${varl1:-/data/haos}/ ; ls -al ${varl1:-/data/haos}/ 
#
# template 
!!! template_copy haos.yml ${varl1:-/data/haos}/docker-compose.yml ; cat ${varl1:-/data/haos}/docker-compose.yml
vi2 ${varl1:-/data/haos}/docker-compose.yml
# http://yourdomain.com:8123
cd ${varl1:-/data/haos}/ ; docker-compose ps
cd ${varl1:-/data/haos}/ ; docker-compose up -d
cd ${varl1:-/data/haos}/ ; ( trap 'return' SIGINT ; docker-compose logs -f )
cd ${varl1:-/data/haos}/ ; docker-compose down
!!! cd ${varl1:-/data/haos}/ ; docker-compose down -v
cd ${varl1:-/data/haos}/ ; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varSH__bash
#
curl $( echo localhost localhost/index.php $HOSTNAME |pipemenu) 




%%% {submenu_docker}docker compose nginx reverse proxy [dkn]
%% dockersvc
%% [ "$mydomain" ] && echo "MyDomain: $mydomain"
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@npm"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/npm}/{data,letsencrypt,mysql} 
cd ${varl1:-/data/npm}/ ; ls -al ${varl1:-/data/npm}/ 
#
# template -> nginx proxy // mariadb
!!! template_copy npm.yml ${varl1:-/data/npm}/docker-compose.yml ; cat ${varl1:-/data/npm}/docker-compose.yml
vi2 ${varl1:-/data/npm}/docker-compose.yml
# http://yourdomain.com:81 -> admin@example.com // changeme
cd ${varl1:-/data/npm}/ ; docker-compose ps
cd ${varl1:-/data/npm}/ ; docker-compose up -d
cd ${varl1:-/data/npm}/ ; ( trap 'return' SIGINT ; docker-compose logs -f )
cd ${varl1:-/data/npm}/ ; docker-compose down
!!! cd ${varl1:-/data/npm}/ ; docker-compose down -v
cd ${varl1:-/data/npm}/ ; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varSH__bash
#
curl $( echo localhost localhost/index.php $HOSTNAME |pipemenu) 




%%% {submenu_docker}docker compose next-cloud [dkc]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@nextcloud"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/nextcloud}/{nextcloud,apps,config,data,theme}
cd ${varl1:-/data/nextcloud}/ ; ls -al ${varl1:-/data/nextcloud}/ ${varl1:-/data/nextcloud}/*
cat ${varl1:-/data/nextcloud}/docker-compose.yml
#
# template -> nextcloud,mariadb,tikaserver,elasticsearch
!!! template_copy nextcloud.yml ${varl1:-/data/nextcloud}/docker-compose.yml ; cat ${varl1:-/data/nextcloud}/docker-compose.yml
# 
vi2 ${varl1:-/data/nextcloud}/docker-compose.yml
#
cd ${varl1:-/data/nextcloud}/ ; docker-compose ps
cd ${varl1:-/data/nextcloud}/ ; docker-compose up -d
cd ${varl1:-/data/nextcloud}/ ; docker-compose down
cd ${varl1:-/data/nextcloud}/ ; docker-compose exec nextcloud bash
!!! cd ${varl1:-/data/nextcloud}/ ; docker-compose down -v
#
curl $( echo localhost localhost/index.php localhost/phpmyadmin localhost:3300 $HOSTNAME |pipemenu) 
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps





%%% {submenu_docker}docker compose caddy [dkca]
%% dockersvc
%% [ "$mydomain" ] && echo "mydomain: $mydomain"
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 공사중
# 내도메인 정보 환경파일에 넣거나 직접 입력 
[ ! "$mydomain" ] && echo "mydomain=varMyDomain" >> ~/go.private.env && . ~/go.private.env
export mydomain=varMyDomain
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@caddy"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/caddy}/site 
cd ${varl1:-/data/caddy}
ls -al ${varl1:-/data/caddy}/ ${varl1:-/data/caddy}/*
cat ${varl1:-/data/caddy}/docker-compose.yml
#
# template -> caddy.yml Caddyfile
!!! template_copy caddy.yml ${varl1:-/data/caddy}/docker-compose.yml ; cat ${varl1:-/data/caddy}/docker-compose.yml
!!! template_copy caddyfile.yml ${varl1:-/data/caddy}/Caddyfile ; cat ${varl1:-/data/caddy}/Caddyfile
sed -i 's|example.com|varYourDomain|g' ${varl1:-/data/caddy}/Caddyfile ; cat ${varl1:-/data/caddy}/Caddyfile
!!! rbackup ${varl1:-/data/caddy}/site/index.html && echo -e "hi caddy" > ${varl1:-/data/caddy}/site/index.html ; cat ${varl1:-/data/caddy}/site/index.html
#
vi2 ${varl1:-/data/caddy}/docker-compose.yml
vi2 ${varl1:-/data/caddy}/Caddyfile
vi2 ${varl1:-/data/caddy}/site/index.html
#
cd ${varl1:-/data/caddy}; docker-compose ps
cd ${varl1:-/data/caddy}; docker-compose up -d
cd ${varl1:-/data/caddy}; docker-compose down
cd ${varl1:-/data/caddy}; ( trap 'return' SIGINT ; docker-compose logs -f )
!!! cd ${varl1:-/data/caddy}; docker-compose down -v
#
docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) ash
#
curl $( echo https://localhost localhost/index.html http://$mydomain https://$mydomain| pipemenu) 
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps















%%% {submenu_com}ansible 관리 자동화 [ansible]
# python3 와 ssh 를 이용하여 서버관리 자동화
# 가상환경의 경우 ansible 위치 조정 
source ansible_venv/bin/activate
echo "source ansible_venv/bin/activate" >> ~/.bashrc
# 
# hosts
rbackup /etc/ansible/hosts ; mkdir -p /etc/ansible/ ; echo "127.0.0.1" > /etc/ansible/hosts
# example hosts
echo -e "google.byus.net\n\n[web]\ng1.byus.net\ng2.byus.net\nhh.byus.net\n\n[db]\nhh.byus.net" >> /etc/ansible/hosts ; cat /etc/ansible/hosts
vi2 /etc/ansible/hosts
# hosts 에 지정된 서버는 ssh 공개키를 심어서 비번없이 로그인이 가능한 상태로 설정
#
ansible all -m ping 
ansible web -m ping
# 
ansible all -a "bash -c 'hostname && pstree && sleep 2'"
ansible all -a "bash -c 'varCommands'"
# 서버 모든 정보 확인 
ansible web -m setup
ansible all -m setup -a "filter=ansible_dist*"
# install sample
!!! template_copy playbook.yml ~/nginx_install.yml ; cat ~/nginx_install.yml 
vi2 varPlaybookPATH__@@root@@nginx_install.yml ; ansible-playbook varPlaybookPATH__@@root@@nginx_install.yml
# script exec sample
!!! template_copy playbook_script.yml ~/playbook_script.yml ; cat ~/playbook_script.yml
echo "pstree; ps -ef |grep -E \"ssh|go.sh\"" > /root/pstree.sample.sh
vi2 varPlaybookPATH__@@root@@playbook_script.yml ; ansible-playbook varPlaybookPATH__@@root@@playbook_script.yml 
#
vi2 varPlaybookPATH ;; ansible-playbook varPlaybookPATH
#
#
ansible --version  
explorer $HOME/ansible_venv/
# install
yyay python3 
yyay ansible
# 가상환경일때 install
yyay python3-venv
python3 -m venv ansible_venv
pip install ansible




%%% {submenu_com}GitHub / Git [git]
# clone
cd varDIR__@@root
git clone varProjectURL
# init && push
mkdir -p $HOME/varProjectDIR__git_project && cd $HOME/varProjectDIR__git_project
cd $HOME/varProjectDIR__git_project 
git init ; ls -al
git remote add origin https://github.com/varName/varProject.git
git add .
git commit -m "varCommit"
git branch -M main 
git push -u origin main
# edit
git add varFILE
git commit -m "varCommitEdit"
git push -u origin main
# branch
git branch
git branch varNewBranch
git checkout -b varBranch
git branch -d varBranch
# push_branch
git add .
git commit -m "varCommitEdit"
git push -u origin varBranch
#
# install && config https://github.com/ (account+)
yyay git ; echo ; git --version
git config --global user.name varName
git config --global user.email varEmail
git config --list
explorer $HOME/.gitconfig







%%% {submenu_hidden}java/ php/ perl/ python [java]
# apache2-utils
htpasswd -nb varAdmin__admin varPW__web_auth_pw || yyay apache2-utils
# java
yyay openjdk-17-jdk
# jdk8 repo
sudo echo "deb http://ftp.debian.org/debian stretch-backports main" | sudo tee -a /etc/apt/sources.list.d/stretch-backports.list ;
sudo echo "deb http://deb.debian.org/debian oldoldstable main" | sudo tee -a /etc/apt/sources.list.d/bookworm-oldoldstable.list
echo "deb http://deb.debian.org/debian/ oldoldstable main" >> /etc/apt/sources.list 
add-apt-repository ppa:webupd8team/java
vi2 /etc/apt/sources.list 
aptupup
yyay -t stretch-backports openjdk-8-jdk
yyay openjdk-8-jdk
yyay oracle-java8-installer
# default java setting
which java
update-alternatives --list java
sudo update-alternatives --config java
# linux_version check
lsb_release -a


%%% {submenu_sys}annyung3 linux (centos7 base) [an3]
# centos7 minimal 설치후 an3 로 변경
# https://joungkyun.gitbook.io/annyung3-installation-guide/chapter1
yum install -y perl
curl -o bootstrap http://mirror.oops.org/pub/AnNyung/3/inst/bootstrap 
curl -o bootstrap http://ftp.kr.freebsd.org/pub/AnNyung/3/inst/bootstrap
bash bootstrap
vi2 bootstrap
vi2 /usr/share/AnNyung/functions
yum update
# oops-firewall 
yum -y install kmod-geoip
# geoip download & database
cd /usr/share/GeoIP ; curl -O http://mirror.oops.org/pub/Security/GeoIP-Legacy/GeoIPCountryWhois.csv ; curl -O http://mirror.oops.org/pub/Security/GeoIP-Legacy/GeoIPv6.csv ; /usr/bin/geoip-csv2bin 1 ; ls -al
# ex) RU/CN ban , ssh KR only
echo "%-A INPUT -m geoip --src-cc RU -j DROP" >> /etc/oops-firewall/user.conf 
echo "%-A INPUT -m geoip --src-cc CN -j DROP" >> /etc/oops-firewall/user.conf 
echo "%-A INPUT -p tcp --dport 22 -m geoip ! --src-cc KR -j DROP" >> /etc/oops-firewall/user.conf
vi2 /etc/oops-firewall/user.conf
systemctl restart oops-firewall
systemctl enable oops-firewall ; systemctl start oops-firewall ; systemctl status oops-firewall
# repo list 
for repo in $(yum repolist 2>/dev/null | awk '$1 == "*" {print $2}' | sed 's/:$//'); do filename=$(echo $repo | sed 's/://g') ; yum --disablerepo='*' --enablerepo="$repo" list available 2>/dev/null > "/root/${filename}.repo.list.txt" ; done ; cat /root/AN*.list.txt | sort -u > /root/AN.repo.list.txt.all ; ls -al /root/*.repo.list.txt*
vi2 $( ls -1 /root/*.list.txt /root/*.list.txt.all | pipemenu )
grep -i "varSearch" /root/*.repo.list.txt | cgrep varSearch
yum -y install varPackage
explorer /etc/yum.repos.d/


%%% {submenu_sys}annyung2 linux (centos6 base) vault.repo set [an2]
# fast mirror enable -> 0 
vi2 /etc/yum/pluginconf.d/fastestmirror.conf 
# 기존 repolist 백업 
mkdir -p /etc/yum.repos.d/backup-repo && mv /etc/yum.repos.d/CentOS-*.repo* /etc/yum.repos.d/backup-repo/
# fast jp server set
!!! template_copy centos-vault.repo /etc/yum.repos.d/centos-vault.repo
vi2 /etc/yum.repos.d/centos-vault.repo
# or default vault server set
!!! template_copy vault.repo /etc/yum.repos.d/centos-vault.repo
vi2 /etc/yum.repos.d/centos-vault.repo
# epel6 기존 백업및 archive repo 갱신
mv /etc/yum.repos.d/epel*.repo* /etc/yum.repos.d/backup-repo/
!!! template_copy epel6.repo /etc/yum.repos.d/epel6.repo
vi2 /etc/yum.repos.d/epel6.repo
# 
yum clean all ; yum repolist
yum update
explorer /etc/yum.repos.d/
# centos6 ranger install (epel6 base)
yy zstd ranger 
# centos6 ranger install (python2 base)
yy git 
cd /backup ; git clone https://github.com/ranger/ranger.git
cd ranger ; git checkout v1.8.1 ; make install






%%% {submenu_sys}annyung1 linux (centos5 base) [an]
pkgdb -v
pkgsysupdate -v
pkgkernel -v
pkgkernel -i varKernel__kernel-bigmem
!!! pkgkernel -r varA 
pkginfo -l > /root/pkginfo.txt ; cat /root/pkginfo.txt | less -R 
vi2 /root/pkginfo.txt
# pkg install
pkgadd -u $( cat /root/pkginfo.txt |grep "설치 안됨"|awk '{print $1}'|sort -u| pipemenu )
pkgadd -u varPKGname
rpm -ql varPKGname
# apm
pkginfo -l -v varPKGname__apache
pkginfo -l -v php
pkginfo -l -v mysql
# daemon set
ntsysv
vi2 /etc/sysconfig/mysql
vi2 /etc/sysconfig/i18n
vi2 /etc/sysconfig/hwconf
explorer /etc/
# etc
[ ! "$(grep "/bin/pass" /etc/shells)" ] && echo "/bin/pass" >> /etc/shells



%%% {submenu_sys}epel repo add [epel]
# EPEL 는 RHEL/CentOS의 일부가 아니지만 모니터링등 많은 오픈 소스
# 패키지를 제공하여 주요 Linux 배포판용으로 설계. 
#
# CentOS 7
yum install epel-release
# CentOS 6 (expired) -> epel6 기존 백업및 archive repo 갱신
mkdir -p /etc/yum.repos.d/backup-repo ; mv /etc/yum.repos.d/epel*.repo* /etc/yum.repos.d/backup-repo/
!!! template_copy epel6.repo /etc/yum.repos.d/epel6.repo
vi2 /etc/yum.repos.d/epel6.repo
# RHEL 9
subscription-manager repos --enable codeready-builder-for-rhel-9-$(arch)-rpms
dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm
# RHEL 8
subscription-manager repos --enable codeready-builder-for-rhel-8-$(arch)-rpms
dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm
# Rocky/AlmaLinux 9
dnf config-manager --set-enabled crb
dnf install epel-release
# Rocky/AlmaLinux 8
dnf config-manager --set-enabled powertools
dnf install epel-release
#
yum clean all ; yum repolist
yum update




%%% {submenu_com}irc chat [irc]
irssi
# irssi config
mkdir -p ~/.irssi/ ; echo -e 'servers = (\n  {\n    address = "varIRCServer__irc.dankun.net";\n    chatnet = "Dankun";\n    port = "6667";\n    password = "";\n    use_ssl = "no";\n    ssl_verify = "no";\n    autoconnect = "yes";\n  }\n);\n\nchatnets = {\n  Dankun = {\n    type = "IRC";\n    nick = "varNick";\n    autosendcmd = "/join #gosh";\n  };\n};\n\nsettings = {\n  core = { real_name = "varNick"; user_name = "varNick"; nick = "varNick"; };\n};' > ~/.irssi/config
vi2 ~/.irssi/config
# irc client install
yyay irssi 


%%% {submenu_sys}termux (android-linux) [ter]
# https://f-droid.org/repo/com.termux_118.apk
termux-wake-lock ; termux-setup-storage 
( whoami ; ifconfig ; curl ifconfig.me ) | push
whoami ; passwd
# termux 실행시 sshd / crond 구동 .bashrc
echo -e 'termux-wake-lock\n(( $(ps -ef|grep -c [s]shd ) == 0 )) && sshd\n(( $(ps -ef|grep -c [c]rond ) == 0 )) && crond\n' >> $HOME/.bashrc ; echo -e 'export VISUAL=vim; export EDITOR="$VISUAL"' >> ~/.bashrc ; echo -e "alias l='ls'\nalias ll='ls -l'\nalias la='ls -al'\nalias go='bash $HOME/go.sh'" >> $HOME/.bashrc 
ln -s /data/data/com/termux/files/usr $HOME/root ; ln -s /data/data/com/termux/files/usr/etc $HOME/etc ; ln -s /data/data/com/termux/files/usr/var $HOME/var ; ln -s /data/data/com/termux/files/usr/spool/cron $HOME/cron ; ln -s /data/data/com/termux/files/usr/tmp $HOME/tmp 
# ssh
vi2 $( echo $HOME/.bashrc $HOME/.ssh/config $HOME/etc/ssh/sshd_config $HOME/cron/$(whoami) | pipemenu )
!!! pkill sshd; sshd
ps -ef|grep -E "sshd|crond|autossh"
(( $(ps -ef|grep -c [s]shd ) == 0 )) && sshd ; (( $(ps -ef|grep -c [c]rond ) == 0 )) && crond ; (( $(ps -ef|grep -c [a]utossh ) == 0 )) && [ -f $HOME/.termux/boot/autossh.sh ] && bash $HOME/.termux/boot/autossh.sh
# pkg
pkg update -y ; pkg upgrade -y
pkg list-all > $HOME/pkglist.txt ; vi2 $HOME/pkglist.txt
cat $HOME/pkglist.txt |grep varSEARCH
pkg install -y varPKG
pkg install -y vim wget proot openssh termux-api autossh termux-services python ranger
pkg list-installed
# termux-setup-storage
explorer /data/data/com.termux/files/home/storage/downloads/ 
# 외부에서 스마트폰 ssh 접속 key set
ssh-copy-id -p 8022 -i id_rsa.pub varTerMuxHOST
ssh -p 8022 varTermuxUser@varTerMuxHOST
# 역터널링 설정(외부에서 폰:8022 접속) 공인ip접근시 공유기포트포워딩
ssh -f -N -R varPORT__2222:localhost:8022 root@varRemotehost -o ServerAliveInterval=60 -o ServerAliveCountMax=1440 
# 역터널링 접속 스크립트 전송
echo "ssh $(whoami)@localhost -p varPORT__2222" | ssh root@varRemotehost "cat > $HOME/termux.con.sh"
# 리모트 서버에서 termux 서버 접속 
cat $HOME/termux.con.sh && readx &&  eval $(cat $HOME/termux.con.sh )
# 역터널링 해제 ( 리모트 or termux 로컬 )
lsof -i:varPORT__2222 | awknr2 | awk2 | xargs kill 
lsof -i:varPORT__8022 | awknr2 | awk2 | xargs kill 
# 역터널링 autossh runit sv add 
mkdir -p /data/data/com.termux/files/usr/var/service/autossh/ && echo -e "#!/data/data/com.termux/files/usr/bin/sh\nexec autossh -M 0 -N -R varPORT__2222:localhost:8022 root@varRemotehost" > /data/data/com.termux/files/usr/var/service/autossh/run ; chmod +x /data/data/com.termux/files/usr/var/service/autossh/run
# runit
svc=$( echo autossh crond sshd | pipemenu ) ;; sv-enable $svc ; sv up $svc
svc=$( echo autossh crond sshd | pipemenu ) ;; sv-disable $svc ; sv down $svc
svc=$( echo autossh crond sshd | pipemenu ) ;; sv status $svc
pkg install -y runit
explorer /data/data/com.termux/files/usr/var/service/





# out
export rootpart=varRhostRootpartiton ; export rootpartnew=${rootpart//sda/sdb}
export bootpart=varRhostBootpartiton__@@dev@@sda1 ; export bootpartnew=${bootpart//sda/sdb}
: !검토 tgz ; echo "time ssh $rhost \"tar czfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / \" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | tar xzfp - -C /mnt/$(basename $rootpartnew)/"


%%% 물리서버->가상서버 online migration [p2v]
%% echo "host:$rhost boot:$bootpart bootnew:$bootpartnew root:$rootpart rootnew:$rootpartnew rootpartsize=${rootpartsize}M"
# 가상서버에 쓰일 sda 를 임시 리눅스 sdb 에 연결후 임시 리눅스에서 p2v 작업
# 물리서버 호스트/부트파티션/루트파티션 설정 (ex.abc.com /dev/sda1 /dev/sda7)
export rhost=varRhost
ssh $rhost "fdisk -l;echo;df" ; echo ; fdisk -l /dev/sdb
# root boot 지정
export rootpart=$( ssh $rhost "df" | awk '$6 == "/" {print $1}') ; export rootpartnew=${rootpart//sda/sdb} ; export bootpart=$( ssh $rhost "df" | awk '$6 == "/boot" {print $1}') ; export bootpartnew=${bootpart//sda/sdb} ; export rootpartsize=$( ssh $rhost "df -m" |awk '$6 == "/" {print $3}') 
# MBR copy
fdisk -l ; df 
!!! ssh $rhost "dd if=/dev/sda bs=512 count=1" | dd of=/dev/sdb bs=512 count=1
# MBR partition table copy 
# 디스크 사이즈가 정확히 일치하지 않는경우, Extended/End 파티션 체크
!!! ssh $rhost "sfdisk -d /dev/sda" > /root/sda.partition_table.sfdisk ; cat /root/sda.partition_table.sfdisk
vi2 /root/sda.partition_table.sfdisk 
sfdisk /dev/sdb < /root/sda.partition_table.sfdisk
fdisk /dev/sdb
# boot partiiion copy (무압축/zstd)
!!! time ssh $rhost "dd if=$bootpart bs=4M" | dd of=$bootpartnew bs=4M ; push
!!! time ssh $rhost "dd if=$bootpart bs=4M | zstd" | zstd -d | dd of=$bootpartnew bs=4M ; push
# root/ boot mount
varMKFsType__mkfs.ext3 $rootpartnew 
mkdir -p /mnt/$(basename $rootpartnew)/ ; mount $rootpartnew /mnt/$(basename $rootpartnew) ; ls -al /mnt/$(basename $rootpartnew) ; mkdir -p /mnt/$(basename $rootpartnew)/{boot,proc,mnt,sys,tmp} ; mount $bootpartnew /mnt/$(basename $rootpartnew)/boot ; ls -al /mnt/$(basename $rootpartnew)/boot ; df
# sda mount partiation create ex) boot,clone,tmp,var,home 
export sdap=$( ssh $rhost "df" | grep "/dev/sda" | awk '{print $NF}' | sed -e 's/\///g' -e '/^$/d' | paste -sd, )
export exclude=$( ssh $rhost "df" | grep "/dev/sd" | awk '{if ($NF != "/") print "--exclude="$NF}' | paste -sd' ' - )
echo "$sdap" ; echo ; echo "$exclude"
eval "mkdir -p /mnt/$(basename $rootpartnew)/{$sdap}" ; explorer /mnt/$(basename $rootpartnew)/
# 별도 마운트 파티션을 제외한 sda root partition copy -> 검토/zstd/gzip
: !검토 zst ; echo "time ssh $rhost \"tar cfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / | zstd\" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | zstd -d | tar xfp - -C /mnt/$(basename $rootpartnew)/"
!!! : !zstd copy ; eval "time ssh $rhost \"tar cfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / | zstd\" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | zstd -d | tar xfp - -C /mnt/$(basename $rootpartnew)/" ; push
!!! : !gzip copy ; eval "time ssh $rhost \"tar czfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / \" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | tar xzfp - -C /mnt/$(basename $rootpartnew)/" ; push
# 별도 마운트 파티션 mkfs && 수동 마운트후 copy (ncp func) / swap 파티션체크
ssh $rhost "df;echo" ;echo $sdap ;; mkdir -p /mnt/$(basename $rootpartnew)/$(basename varF) ; explorer /mnt/$(basename $rootpartnew)/
varMKFsType__mkfs.ext3 varPartition ; mount varPartition /mnt/$(basename $rootpartnew)/$(basename varF)
!!! time ssh $rhost 'cd varF/ && tar cfp - *| zstd' | { pv 2>/dev/null || cat ; } | zstd -d| tar xfp - -C /mnt/$(basename $rootpartnew)/$(basename varF) ; push
!!! time ssh $rhost 'cd varF/ && tar cfp - *| gzip' | { pv 2>/dev/null || cat ; } | gunzip | tar xfp - -C /mnt/$(basename $rootpartnew)/$(basename varF) ; push
: label 82 swapon ; fdisk -l /dev/sdb ;; mkswap varP
# lilo 혹은 grub 에서 더이상 진행이 안될경우 rescue-mode (boot cd) 로 진입하여 mbr 재설정 
# dd 로 sda img 를 뜨거나 (느린속도) / offline 에서 clonezilla 로 sda img 를 떠서 p2v 도 가능함 










%%% {submenu_sys}역터널링 / 터널링 [tt]
# R 역터널링: ex) 핸드폰이 lte 모드일때 핸폰에서 역터널링 접속을 해두면, 원격에서 
# 핸드폰 termux 로 ssh 접속이 가능함 ssh localhost -p 2222 (서버->클라이언트접속)
ssh -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost
# 터널링만 유지 (터널링이 끊어지면 24시간 동안 재접속시도)
ssh -f -N -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost -o ServerAliveInterval=60 -o ServerAliveCountMax=1440 
# 마찬가지로 외부에서 접속이 안되는 서버 포트 열기 (ex.rdp)
# 윈도우의 경우 putty 로 터널링 연결가능 
ssh -R varRemotePORT__3389:localhost:varLocalPORT__3389 root@varRemotehost
# 접속 유지에 특화 autossh 
# autossh (-M 모니터링포트 -M 0 -> keep-alive)
autossh -M varMonitorPort__0 -f -N -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost
# 터널링 끊기
lsof -i:varPORT__2222 
lsof -i:varPORT__2222 | awknr2 | awk2 | xargs kill 
# L 터널링 (클라이언트->서버접속)
ssh -L varLcalPORT__2222:localhost:varRemotePORT__8022 root@varRemotehost
# D 터널링 (SOCKS 프록시) 브라우저 설정후 이용
ssh -D varProxyPORT__8080 root@varRemotehost
# LD / RD 터널링 (혼합)
ssh -D varProxyPORT__8080 -L varLocalPORT__2222:localhost:varRemotePORT__8022 root@varRemotehost
ssh -D varProxyPORT__8080 -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost
#
yyay autossh



%%% {submenu_hidden}패키지 관리 snap / git / pip [aa]
%% echo -n "Able:" ; { which snap ; which git ; which pip ; } 2>/dev/null | tr "\n" " " ; echo
# snap install
yy epel-release
yyay snapd
systemctl enable --now snapd.socket
ln -s /var/lib/snapd/snap /snap
# git install
yyay git ; echo ; git --version
# pip  install
yyay python3 python3-pip ; ln -s /usr/bin/pip3 /usr/bin/pip






%%% {submenu_sys}tmp 폴더와 파일 / 난수 [tmp]
# tmpfile 생성 
: ${TMPDIR:=/tmp}; tmpfile=$(mktemp ${TMPDIR%/}/my_tmp_file.XXXXXX) || { echo "Failed to create temp file"; exit 1; } ; echo $tmpfile ; ls -al $tmpfile ; rm -f $tmpfile
# tmpdir 생성
: ${TMPDIR:=/tmp}; tmpdir=$(mktemp -d ${TMPDIR%/}/my_tmp_dir.XXXXXX) || { echo "Failed to create temp directory"; exit 1; } ; echo $tmpdir ; ls -ld $tmpdir ; rm -rf $tmpdir
# 임의의 6자리 숫자 생성 (인증키용) 
echo $(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))
echo $RANDOM ; echo $RANDOM$RANDOM|cut -c -6 ; echo $RANDOM$RANDOM|rev|cut -c -6|rev 
printf "%.06d\n" "$(shuf -i 0-999999 -n 1)"
printf '%.06s\n' "$(head -n3 /dev/urandom | tr -dc 0-9)"
# 난수 알파벳 생성 (6바이트 3바이트)
openssl rand -base64 6 ; openssl rand -base64 3 ; printf '%.6s\n' "$(openssl rand -base64 6)"
# 고유ID 
uuidgen;uuidgen;uuidgen
# 영어와숫자로된 6자리 난수
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc A-Za-z0-9)"
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc a-z0-9)"
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc a-z)"
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc 0-9)"
# 임의의 단어 난수
shuf -n 1 /usr/share/dict/words
shuf -n 1 /usr/share/dict/korean
# 단어를 배열에 넣고 출력 (메모리사용/속도지연)
awk 'BEGIN { srand(); } { lines[NR] = $0; } END { print lines[int(rand() * NR + 1)]; }' /usr/share/dict/words
awk 'BEGIN { srand(); } { lines[NR] = $0; } END { print lines[int(rand() * NR + 1)]; }' /usr/share/dict/korean
# 줄수를 가져와 랜덤줄수 sed (파일2회i/o)
f="/usr/share/dict/words"; l=$(wc -l < "$f"); r=$(( ($RANDOM$RANDOM) % l + 1)); sed -n "${r}p" "$f"
f="/usr/share/dict/korean"; l=$(wc -l < "$f"); r=$(( ($RANDOM$RANDOM) % l + 1)); sed -n "${r}p" "$f"
#
# 단어 난수2개 이어쓰기
shuf -n 2 /usr/share/dict/korean | tr -d '\n'; echo
awk 'BEGIN { srand(); } { lines[NR] = $0; } END { print lines[int(rand() * NR + 1)] lines[int(rand() * NR + 1)]; }' /usr/share/dict/korean
f="/usr/share/dict/korean"; l=$(wc -l < "$f"); r1=$(( ($RANDOM$RANDOM) % l + 1)); r2=$(( ($RANDOM$RANDOM) % l + 1)); word1=$(sed -n "${r1}p" "$f"); word2=$(sed -n "${r2}p" "$f"); printf "%s%s\n" "$word1" "$word2"
# 영단어 패키지 설치 
yy words || ay wamerican
curl http://byus.net/koreane.txt -o /usr/share/dict/korean
curl http://byus.net/koreanu.txt -o /usr/share/dict/korean



%%% {submenu_sys}중복실행방지 코드삽입 [dup]
# 시스템 감시 용도의 스크립트등 중복으로 실행되면 안되는 경우 
# 아래의 runlockadd 함수를 스크립트에 삽입하여, 중복실행을 방지합니다.
# ex) cron 1분 간격 실행, load 가 높아 1분 안에 종료 않는 경우 중복 실행 방지
#
# test
export tmpscript="${TMPDIR:=/tmp}/tmp.sh"
echo -e "#!/bin/bash\ntop" > $tmpscript ; chmod 700 $tmpscript ; RED1 ; cat $tmpscript ; RST 
runlockadd $tmpscript; echo; RED1 ; cat $tmpscript.1 ; RST ; echo ; YEL1; cat $tmpscript ; RST 
cdiff $tmpscript.1 $tmpscript
screen -dmS test-top $tmpscript ;; ps -ef|grep tmp.sh ;; readx ; $tmpscript
# test end
ps -ef|grep tmp.sh|awk2 |xargs kill 
unset tmpscript
#
# 
declare -f runlockadd
runlockadd varScriptPATH ; vi2 varScriptPATH



%%% {submenu_hidden}bash 변수 사용예제 [var]
# 변수 디폴트값 출력혹은 설정
unset var; echo "Result: ${var:=default}"; echo "\$var = $var"
unset var; echo "Result: ${var:-default}"; echo "\$var = $var"
unset var; echo "Result: ${var:+default}"; echo "\$var = $var"
unset var; echo "Result: ${var:?error}"; echo "\$var = $var" 2>/dev/null
# 변수 길이
var="value"; echo "Result: ${#var}"; echo "After: \$var = $var"
# 변수 자르기
var="hello"; echo ${var#?}; echo ${var%${var#?}} ; echo ${var:0:1}
var="/path/to/file.txt"; echo "Result: ${var#*/}"; echo "After: \$var = $var"
var="/path/to/file.txt"; echo "Result: ${var##*/}"; echo "After: \$var = $var"
var="/path/to/file.txt"; echo "Result: ${var%/*}"; echo "After: \$var = $var"
var="/path/to/file.txt"; echo "Result: ${var%%/*}"; echo "After: \$var = $var"
# dirname / basename 
echo "$0 // $(dirname $0) //  $(basename "$0" )  // $(basename "$0" .sh)"
echo "$0 // ${0%/*} // ${0##*/} // $( t=${0##*/}; echo ${t%.*})"
# 변수 편집 // realpath
var="/root/./home/user"; echo "Result: ${var//\/\./}"; echo "After: \$var = $var"
var="/root/../home/user/./folder"; echo "Before: \$var = $var"; var=$(echo "$var" | sed -e 's/\/\.\//\//g' | awk -F'/' -v OFS="/" '{top=1; for (i=2; i<=NF; i++) {if ($i == "..") {top--; delete stack[top];} else if ($i != "") {stack[top]=$i; top++;}} for (i=0; i<top; i++) {printf "%s", stack[i]; printf i==top-1?"":OFS;}}');echo "After: \$var = $var"
var="/root/../home/user/./folder";result=$(readlink -f "$var"); echo "Result: $result" ;echo "After: \$var = $var"
var="/root/../home/user/./folder";result=$(realpath "$var");echo "Result: $result";echo "After: \$var = $var"
var="/root/../home/user/./folder";result=$(cd "$(dirname "${var}")" ; echo $(pwd));echo "Result: $result";echo "After: \$var = $var"
# 변수 배열 ; 배열 출력
array=($(seq 1 5)); for i in "${array[@]}"; do echo $i; done
# printf
printf "%-15s %5d\\n" "Apples" 5
printf "%.2f\\n" 3.141592
printf "%x\\n" 15
printf "%+10s\\n" "hello"
printf "%.5s\\n" "abcdefghijk"
printf "Hello\\tworld! \\n"
# 서브쉘과 현재쉘 변수 
c=0 ; ( a=1; b=2 ; c=$(( a + b )) ) ; echo $c
c=0 ; { a=1; b=2 ; c=$(( a + b )); } ; echo $c
# 간접변수참조
a=b ; b=c ; echo ${!a}




%%% {submenu_hidden}awk/sed 변수 사용예제
# 네모
awk 'BEGIN{OFS=""; ORS="\n"; for(i=1; i<=5; i++){for(j=1; j<=5; j++)$j="#"; print}}'
# 세모
awk 'BEGIN{OFS=""; ORS="\n"; for(i=1; i<=5; i++){for(j=1; j<=i; j++)$j="#"; print}}'
# 여러 개의 연속된 공백을 하나의 공백으로 
df | sed 's/ \+/ /g'
df | awk '{$1=$1}1'




%%% {submenu_hidden}dialog [di]
# msgbox
dialog --title "Message" --msgbox "This is a sample message box." 10 50
height=$(($(tput lines)*70/100)) ; width=$(($(tput cols)*70/100)); dialog --title "Message" --msgbox "This is a sample message box." $height $width
# yesno
dialog --stdout --title "Question" --yesno "Do you want to continue?" 10 50 ; echo "You chose: $?"
# inputbox
dialog --stdout --title "Inputbox - To take input from you"  --backtitle "Linux Shell Script Tutorial" --inputbox "Enter your name please" 8 60 
# checklist
CHOICES=$(dialog --stdout --checklist "Choose toppings:" 10 40 3 1 Cheese on 2 "Tomato Sauce" off 3 Anchovies off ); fclear; echo "You chose: $CHOICES"
# menulist
CHOICE=$(dialog --stdout --title "Menu" --menu "Choose an option:" 10 30 3 1 "Option 1" 2 "Option 2" 3 "Option 3" ); fclear; echo "You chose: $CHOICE"
# radiolist
CHOICE=$(dialog --stdout --title "Radio Menu" --radiolist "Choose an option:" 10 30 3 1 "Option 1" off 2 "Option 2" off 3 "Option 3" off ); fclear; echo "You chose: $CHOICE"
# progress
for i in `seq 1 100`; do echo $i; sleep 0.02; done | dialog --gauge 'File copy progress'  10 60
# update example
dialog --title "System Update" --yesno "Do you want to update the system?" 10 60; response=$?; case $response in 0) echo "System update in progress..." && sudo apt-get update && sudo apt-get upgrade;; 1) echo "Update cancelled.";; esac
# proxmox pct example
vmid=$(dialog --title "VMID Selection" --menu "Choose VMID from the following list:" 22 76 16 $(pct list | awk 'NR>1 {print $1,$3"__"$2}') 3>&1 1>&2 2>&3); fclear; cmd=$(dialog --title "PCT Command" --menu "Choose command" 22 76 5 1 "Start" 2 "Stop" 3 "Reboot" 4 "Config" 5 "Enter" 3>&1 1>&2 2>&3); fclear; case $cmd in 1) cmd="start";; 2) cmd="stop";; 3) cmd="reboot";; 4) cmd="config";; 5) cmd="enter";; esac; fclear; if [ -n "$vmid" ]; then fclear && echo "Executing 'pct $cmd $vmid'" && pct $cmd $vmid; else fclear && echo "No VMID selected."; fi ; echo ; pct list |cgrep1 running
# proxmox qm example
vmid=$(dialog --title "VMID Selection" --menu "Choose VMID from the following list:" 22 76 16 $(qm list | awk 'NR>1 {print $1,$2"__"$3}') 3>&1 1>&2 2>&3); fclear; cmd=$(dialog --title "QM Command" --menu "Choose command" 22 76 4 1 "Start" 2 "Stop" 3 "Reset" 4 "Config" 3>&1 1>&2 2>&3); fclear; case $cmd in 1) cmd="start";; 2) cmd="stop";; 3) cmd="reset";; 4) cmd="config";; esac; fclear; if [ -n "$vmid" ]; then fclear && echo "Executing 'qm $cmd $vmid'" && qm $cmd $vmid; else fclear && echo "No VMID selected."; fi ; echo ; qm list |cgrep1 running
# fdialog (행변수) / fdialog1 (열변수)
declare -f fdialog;echo; declare -f fdialog1
/bin/df -h | fdialog
ls -1 / | fdialog
ls -ld /* | grep ^d | awk '{dir=$NF; $NF=""; print dir,$0}' | fdialog
ls -ld /* | grep ^d | awk '{dir=$NF; $NF=""; print dir,$0}' | fdialogw
ls | fdialog1
eval $( echo env top htop bashtop neofetch iftop dfmonitor | fdialog1 ) 
# install
yyay dialog





%%% {submenu_hidden}ansi code [ansi]
%% echo ; { echo -e "\033[0m TcBc: Reset \033[0m [0m] \033[1m Tc: Bold \033[1m [1m] \033[3m Tc: Italic \033[0m [3m]\n\033[4m Tc: Underline \033[0m [4m] \033[7m Bc: Invert \033[0m [7m] \033[9m Tc: Strike \033[0m [9m]\n\033[22m Bold off \033[0m [22m] \033[23m Italic off \033[0m [23m] \033[24m Under off \033[0m [24m]\n\033[27m Invert off \033[0m [27m] \033[29m Strike off \033[0m [29m] \033[30m Tc: Blk \033[0m [30m]\n\033[31m Tc: Red \033[0m [31m] \033[32m Tc: Grn \033[0m [32m] \033[33m Tc: Yel \033[0m [33m]\n\033[34m Tc: Blu \033[0m [34m] \033[35m Tc: Mag \033[0m [35m] \033[36m Tc: Cyn \033[0m [36m]\n\033[37m Tc: Wht \033[0m [37m] \033[39m Default Tc \033[0m [39m] \033[40m Bc: Blk \033[0m [40m]\n\033[41m Bc: Red \033[0m [41m] \033[42m Bc: Grn \033[0m [42m] \033[43m Bc: Yel \033[0m [43m]\n\033[44m Bc: Blu \033[0m [44m] \033[45m Bc: Mag \033[0m [45m] \033[46m Bc: Cyn \033[0m [46m]\n\033[1;47m Bc: Wht \033[0m [1;47m] \033[49m Default Bc \033[0m [49m]" ;echo "-";echo "-";echo; paste <(for i in `seq 40 47`; do echo -e "\033[01;37;${i}m ABCDEFG [1;37;${i}m] \033[0m"; done) <(for i in `seq 40 47`; do echo -e "\033[01;4;37;${i}m ABCDEFG [1;4;37;${i}m] \033[0m"; done) <(for i in `seq 30 37`; do echo -e "\033[0;4;5;${i};47m ABCDEFG [0;4;5;${i};47m] \033[0m"; done); } | column -t ; echo -e "\033[0m" 
#
for code in $(seq 0 107); do printf "\\e[${code}m%s\\e[0m\\n" "ANSI Code $code"; done |less -R
echo -e "\\e[1;33;44m e escape code \\e[0m"
echo -e "\\033[1;33;44m 0133 8bit 27 escape code \\e[0m"
echo -e "\\x1b[1;33;44m x1b 16bit 27 escape code \\e[0m"
# 안시 제거
echo -e "\\033[1;3m2;2;3m\\033[0m" | perl -p -e 's/\\e\[[0-9;]*[MKHJm]//g' 2>/dev/null



%%% SSL 인증서 LetsEncrypt [ssl]
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
%% [ "$mydomain" ] && echo "MyDomain: $mydomain"
# 내도메인 정보 환경파일에 넣거나 직접 입력 
[ ! "$mydomain" ] && echo "mydomain=varMyDomain" >> ~/go.private.env && . ~/go.private.env
export mydomain=varMyDomain
# dns-01 챌린지 과정중 나오는 txt 레코드 복사후 도메인 네임서버 등록사에 가서 등록
# ex) _acme-challenge.yourdomain.com.  IN  TXT "Somewhat long key string"
# 레코드 등록에 시간이 소요될 수 있으며 챌린지 실패시 시간 간격을 두어 재시도
# txt 레코드는 총 2회 인증 요청됨 (인증실패가 계속되면 일정시간 블락)
certbot certonly --manual -d $mydomain -d *.$mydomain --agree-tos --no-bootstrap --manual-public-ip-logging-ok --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory
# webroot key 로 인증하여 인증서 발급 // 와일드카드 인증서는 webroot 방식으로는 불가
certbot certonly --webroot -w varWWWrootPath__@@var@@www@@html -d $mydomain -d www.$mydomain -d varSubDom__m.$mydomain --agree-tos -m "varYourEmail"
# 발급받은 인증서는 3개월간 유효 (2개월후부터 갱신가능)
ls -al /etc/letsencrypt/live/$mydomain/ ; cat /etc/letsencrypt/live/$mydomain/fullchain.pem ; cat /etc/letsencrypt/live/$mydomain/privkey.pem
# 유효기간 확인 및 스케즐 등록 
certbot certificates 
certbot certificates ;; alarm 00001100varExdate__61 "$mydomain SSL 인증서 발급 varExdate__61일이 지났습니다. 수동 갱신하세요." ;
# 인증서 자동 갱신 crontab 일요일 새벽 3시 dry-run 으로 체크요망 
echo "0 3 * * 0 /usr/bin/certbot renew --webroot -w /var/www/html/ -quiet" >> /etc/crontab
# 자동 갱신을 위해선 doamin txt key 인증받은것과 마찬가지로 인증이 필요하며
# 아래 방법은 웹루트에 토큰파일을 자동으로 심어서 인증받는 방법으로 갱신 
certbot renew --webroot -w varWWWrootPath__@@var@@www@@html --dry-run
# 인증서 수동 갱신 (3개월이전)
certbot renew --force-renewal --manual
# nginx apply sample
echo -e "server { \n    listen 443 ssl default_server;\n    http2 on;\n    server_name $mydomain *.$mydomain;\n    root /source;\n    ssl_certificate /etc/letsencrypt/live/$mydomain/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/$mydomain/privkey.pem;\n}\n"
# apache2 apply sample
vi2 /etc/apache2/sites-available/$mydomain.conf
echo -e "<VirtualHost *:443>\n  ServerName $mydomain\n  ServerAlias *.$mydomain\n  DocumentRoot /var/www/html\n  SSLEngine on\n  SSLCertificateFile /etc/letsencrypt/live/$mydomain/fullchain.pem\n  SSLCertificateKeyFile /etc/letsencrypt/live/$mydomain/privkey.pem\n  CustomLog ${APACHE_LOG_DIR}/access.log combined\n  ErrorLog ${APACHE_LOG_DIR}/error.log\n</VirtualHost>\n"
systemctl reload nginx || systemctl reload apache2
# install
yyay certbot




%%% {submenu_sys}인코딩/ 디코딩/ 암호화/ 복호화 [enc]
# web - url{en,de}coding
echo "varWORD" | od -t x1 -A n | tr " " %
echo "varENCWORD" | echo -en "$(sed 's/+/ /g; s/%/\\x/g')"
#
# base64 {en,de}coding 이진 데이터를 ASCII 문자열로 변환 (메일의첨부파일등) 
echo "varWORD" | base64
echo "varENCWORD" | base64 --decode
# base64 (perl) 
echo "varWORD" | perl -MMIME::Base64 -ne 'print encode_base64($_);'
echo "varENCWORD" | perl -MMIME::Base64 -ne 'print decode_base64($_)'
#
# 암호화/복호화 
key=varKEY__mykey; echo -n "varWORD" | openssl enc -aes-256-cbc -e -k $key -A -a -pbkdf2 -iter 100000 ; echo
key=varKEY__mykey; echo -n "varENCWORD" | openssl enc -aes-256-cbc -d -k $key -A -a -pbkdf2 -iter 100000 ; echo
# old_openssl
key=varKEY__mykey; echo -n "varWORD" | openssl enc -des-ede3-cbc -e -k $key -A -a ; echo
key=varKEY__mykey; echo -n "varENCWORD" | openssl enc -des-ede3-cbc -d -k $key -A -a ; echo
# encrypt / decrypt func
echo varWORD | encrypt varKEY__key
echo varEncWORD | decrypt varKEY__key
echo varWORD | encrypt varKEY__key | decrypt varKEY__key 



%%% {submenu_sys}히든메뉴 [hid]
{submenu_hidden}

%%% 텔레그램과 푸시알람 [te]
%% env | grep telegram_
%% [ "$( atqq )" ] && CYN && atqq && RST
%% ps -ef |grep [a]larm_task|awknf8|cgrep "alarm_task_$input"|grep -v "awk"
# 스크립트 에서 텔레그램봇으로 메세지를 전송 
# 최초 사용시 텔레그램 정보(챗봇ID,토큰) 입력
# ex) push varMSG // echo varMSG | push // push
# 스크립트의 결과를 텔레그램으로 받고 싶을때 사용 
push varMSG__var.hello
echo "varMSG__pipe.hello" | push
w | push
# 결과를 명령어와 에러유무를 메세지를 받고 싶을때
eval "sleepdot 10 ; echo i love gosh !!!" ; push "Task ended command: $_  result: $?"
# 결과를 화면과 메세지로 받고 싶을때
sleepdot 10 ; pstree | push
# make 같은 오랜 작업 완료를 메세지로 받고 싶을때 -> 알람용도 
# 인수도 없고 파이프도 없을 경우 $HOSTNAME push 
sleepdot 30 ; push
#
# 지정한 시간에 텔레그램으로 푸시 발송
# go.sh 메인화면에서 ex) "005 [Enter]" 타이머 설정가능
# 0060 은 60분후 푸시 00001300 은 13시에 푸시
# alarm 명령어 생략해도 실행 가능 ( 메인/서브 메뉴 선택화면에서 패턴 인식 ) 
alarm 001  
alarm 005 라면타임
alarm 0060 10분 휴식
alarm $( echo 0010 0030 0060 00120 00180 | pipemenu ) 
alarm varTIMESET_0000xy_or_00xy varMSG
# timer 00 // alarm 0000 
alarm 00001700 퇴근 17시에 합시다.
alarm 000020001 내일 20시 축구.
# 알람삭제
atqq ;; atrm varATNUM
# 
# 환경변수 수정
echo "telegram_chatid=varChatID" >> ~/go.private.env 
echo "telegram_token=varToken" >> ~/go.private.env && chmod 600 ~/go.private.env
vi2 ~/go.private.env
#
yyay at curl






%%% 설명서 / 업데이트 [he]
%% export PATH=$PATH:$(cd "$(dirname "${0}")" ; echo $(pwd)) ; echo "PATH: $PATH"
%% printf "which \$0: $(which $0)\n"
# 리눅스 콘솔에서 서버 관리를 용이하게 할수 있도록 메뉴 구성 
# curl -O byus.net/go.sh && bash go.sh 로 바로 시작가능
# 파일구성 go.sh // go.env // opt. explorer.sh(0.01ver)
# /bin/go 로 soft link 생성되어, 최초 실행후 go [Enter] 로 진입가능
# go.env 파일에 콘솔 명령어들을 입력 하여 메뉴 화면 구성 
# go.env 수정시 메인메뉴에서 conf [Enter] 하면 백업후 vi 수정모드 
# %%% 로 메인 메뉴 시작 - 빈줄로 메뉴 끝
# %% 서브 메뉴 시작시 사전 실행 명령 설정 
# 메인 메뉴 단축키 지원 [a-zzz] 형식  
# 서브 메뉴에 감춰진 단축키도 인식 업데이트 
# 콘솔에서 직접 입력 명령 그대로 최대한 사용
# ;; 로 이어진 명령들은 순차적으로 실행 (앞의 결과를 보고 뒤의 변수를 입력 가능)
# var[A-Z][a-zA-Z0-9_.@]* 는 사용자 변수로 직접 입력 지원 
# varABC__default : 사용자변수 끝에 __기본값 형태로 default 값 사전설정 가능 (ex varPORT__22)
# varABC__default : 기본값에 경로가 필요한 경우 @ 2개 -> / 로 변환됨 
# 명령문에 모든 varABC 가 변경된 후에, bash 에게 명령이 전달됩니다. 
# ~/go.private.env 개인 환경변수 파일 불러와 이용이 가능. 
# var=abc 형태로 등록하며, 스크립트 실행후 env 로 확인가능.
# !!! 는 주의명령으로 명령 실행여부를 한번더 확인 
# 함수 지정하여 호출하여 사용 // go.sh 하단에 함수 설정
# 함수 vi2 는 파일 rotate 백업후 vi 를 진행하는 함수 (a a.1.bak ... a.4.bak)
# opt) explorer 외부스크립트로 파일/폴더 탐색 가능 (파일삭제,편집기능)
# bash2 기준으로 대부분의 리눅스에서 에러 없이 구동되도록 호환성 유지
# /tmp 폴더에 임시 파일을 생성하여 이용
# 현재 콘솔 한글 환경을 추적하여 euc-kr/utf8 한글 메뉴 지원 (강제변경지원:ko) 
# redhat / centos / debian / ubuntu 기준 주요 명령어 기재
# EasterEgg -> .. [Enter] 현재 메뉴구성이 아쉬울때 직접 명령어 입력지원 (.bashrc alias 적용)
# 메인메뉴에서 update [Enter] 로 최신 스크립트 다운로드 가능 
# 
# 제작: 손희태(byus.net // admin // 010-5324-1378)
# 버그/기능개선문의: forsys02@gmail.com 카카오톡문의: byusnet
# 
# backup && update && restart
rbackup $gofile $envorg ; echo "update file: $gofile $envorg" && sleep 1 && [ -f "$gofile" ] && curl http://byus.net/go.sh -o $gofile && chmod 700 $gofile && [ -f "$envorg" ] && curl http://byus.net/go.env -o $envorg && chmod 600 $envorg && exec $gofile 
echo "Basefilepath: $gofile $envorg"
vi2 ~/go.private.env
# go.sh 내장 함수의 내용을 보고 싶을때 ex) ff func_name
declare -f varFunc__vi2
